{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/error-kid@0.0.7/node_modules/error-kid/dist/index.js","../src/errors/CancelledError.ts","../src/errors/TimeoutError.ts","../src/promises/resolve.ts","../src/promises/AbortablePromise.ts","../src/promises/ManualPromise.ts"],"sourcesContent":["var f = Object.defineProperty;\nvar u = (r, t, e) => t in r ? f(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar c = (r, t, e) => u(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction a(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction p(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class n extends Error {\n    constructor(...i) {\n      const o = typeof t == \"function\" ? t(...i) : typeof t == \"string\" ? [t] : t || [];\n      super(...o);\n      c(this, \"type\", e);\n      this.name = r;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: r }), [n, a(n, e)];\n}\nfunction l(r, t, e) {\n  const n = Symbol(r);\n  class s extends p(r, e)[0] {\n    constructor(...o) {\n      super(...o);\n      c(this, \"data\");\n      c(this, \"type\", n);\n      this.data = t(...o);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: r }), [s, a(s, n)];\n}\nexport {\n  p as errorClass,\n  l as errorClassWithData,\n  a as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\r\n\r\nexport const [CancelledError, isCancelledError] =\r\n  errorClass('CancelledError', 'Promise was canceled');","import { errorClass } from 'error-kid';\r\n\r\nexport const [TimeoutError, isTimeoutError] =\r\n  errorClass<[timeout: number, cause?: unknown]>(\r\n    'TimeoutError',\r\n    (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n  );\r\n","export type PromiseResolveResult<T> = [typeof RESOLVED_SYMBOL, T];\r\n\r\nconst RESOLVED_SYMBOL = Symbol('Resolved');\r\n\r\n/**\r\n * @return True if passed value determines that the promise was resolved.\r\n * @param value\r\n * @example\r\n * const promise = new ManualPromise(async (res, rej, signal) => {\r\n *   // Imitate something async here.\r\n *   await new Promise(res => setTimeout(res, 1000));\r\n *\r\n *   if (isResolved(signal.reason)) {\r\n *     // It means that ManualPromise was resolved outside. We probably want to stop executing\r\n *     // the function as long as the result will not affect anything.\r\n *     return;\r\n *   }\r\n *\r\n *   // Otherwise keep doing what we do.\r\n * });\r\n */\r\nexport function isPromiseResolveResult(value: unknown): value is PromiseResolveResult<unknown> {\r\n  return Array.isArray(value) && value[0] === RESOLVED_SYMBOL;\r\n}\r\n\r\nexport function withResolved<T>(value: T): PromiseResolveResult<T> {\r\n  return [RESOLVED_SYMBOL, value];\r\n}","import type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseRejectFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\nimport { TimeoutError } from '../errors/TimeoutError.js';\r\nimport { CancelledError } from '../errors/CancelledError.js';\r\nimport { isPromiseResolveResult, withResolved } from './resolve.js';\r\n\r\nfunction reassignProps<P extends AbortablePromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: AbortablePromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.abort = parentPromise.abort;\r\n  return childPromise;\r\n}\r\n\r\n/**\r\n * Improved version of the JavaScript Promise.\r\n */\r\nexport class AbortablePromise<Result> extends Promise<Result> {\r\n  /**\r\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): AbortablePromise<T> {\r\n    return new AbortablePromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): AbortablePromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): AbortablePromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): AbortablePromise<Awaited<T>> {\r\n    return this.fn(() => value) as AbortablePromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any): AbortablePromise<T> {\r\n    return new AbortablePromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new AbortablePromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new AbortablePromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<Result>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<Result> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let reject!: PromiseRejectFn;\r\n    let abort!: (reason: unknown) => void;\r\n    super((res, rej) => {\r\n      let executor: PromiseExecutorFn<Result> | undefined;\r\n      let options: PromiseOptions | undefined;\r\n\r\n      if (typeof executorOrOptions === 'function') {\r\n        executor = executorOrOptions;\r\n        options = maybeOptions;\r\n      } else {\r\n        options = executorOrOptions;\r\n      }\r\n\r\n      //#region Cleanup section.\r\n      const cleanupFns: VoidFunction[] = [];\r\n      const withCleanup = <F extends (...args: any) => any>(\r\n        fn: F,\r\n      ): (...args: Parameters<F>) => ReturnType<F> => {\r\n        return (...args) => {\r\n          const result = fn(...args);\r\n          cleanupFns.forEach(fn => fn());\r\n          return result;\r\n        };\r\n      };\r\n      //#endregion\r\n\r\n      // We are going to use our controller signal in the executor because we can control it.\r\n      // We can't say the same about the abort signal passed from above, we can't abort it by\r\n      // ourselves.\r\n      const controller = new AbortController();\r\n      const { signal } = controller;\r\n      abort = reason => {\r\n        !signal.aborted && controller.abort(reason);\r\n      };\r\n      const abortReason = () => signal.reason;\r\n      const onAborted = (listener: (reason: unknown) => void): VoidFunction => {\r\n        const wrapped = () => {\r\n          listener(abortReason());\r\n        };\r\n        signal.addEventListener('abort', wrapped, true);\r\n\r\n        const cleanup = () => {\r\n          signal.removeEventListener('abort', wrapped, true);\r\n        };\r\n        cleanupFns.push(cleanup);\r\n        return cleanup;\r\n      };\r\n\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const resolve = withCleanup((result: Result) => {\r\n        res(result);\r\n        abort(withResolved(result));\r\n      }) as PromiseResolveFn<Result>;\r\n      reject = withCleanup(reason => {\r\n        rej(reason);\r\n        abort(reason);\r\n      });\r\n\r\n      //#region Process abortSignal option.\r\n      options ||= {};\r\n      const { abortSignal, rejectOnAbort = true } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          const { reason } = abortSignal;\r\n          if (rejectOnAbort) {\r\n            return reject(reason);\r\n          }\r\n          abort(reason);\r\n        } else {\r\n          // When the passed abort signal aborts, we are also aborting our locally created signal.\r\n          const listener = () => {\r\n            abort(abortSignal.reason);\r\n          };\r\n          abortSignal.addEventListener('abort', listener);\r\n          cleanupFns.push(() => {\r\n            abortSignal.removeEventListener('abort', listener);\r\n          });\r\n        }\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process rejectOnAbort option.\r\n      rejectOnAbort && onAborted(rej);\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          abort(new TimeoutError(timeout));\r\n        }, timeout);\r\n\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      const isAborted = () => signal.aborted;\r\n      const isResolved = () => isPromiseResolveResult(abortReason());\r\n      const resolved = () => {\r\n        const reason = abortReason();\r\n        return isPromiseResolveResult(reason) ? reason[1] as Result : undefined;\r\n      };\r\n      try {\r\n        const result = executor && executor(resolve, reject, {\r\n          abortReason,\r\n          abortSignal: signal,\r\n          isAborted,\r\n          isResolved,\r\n          onAborted,\r\n          onResolved: listener => onAborted(() => {\r\n            isResolved() && listener(resolved() as Result);\r\n          }),\r\n          resolved,\r\n          throwIfAborted() {\r\n            if (isAborted()) {\r\n              throw abortReason();\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.abort = abort;\r\n    this.reject = reject;\r\n  }\r\n\r\n  /**\r\n   * Aborts the promise execution using the specified reason.\r\n   *\r\n   * Not that this method doesn't reject the promise but notifies the executor using its context.\r\n   * To perform the same operation but also reject the promise, use the `reject()` method.\r\n   * @param reason - abort reason.\r\n   * @see reject\r\n   */\r\n  abort: (reason?: unknown) => void;\r\n\r\n  /**\r\n   * Aborts the promise with the cancel error.\r\n   */\r\n  cancel(): void {\r\n    this.abort(new CancelledError())\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): AbortablePromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): AbortablePromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return reassignProps(super.finally(onFinally) as AbortablePromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: PromiseRejectFn;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): AbortablePromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return reassignProps(super.then(onFulfilled, onRejected) as AbortablePromise<A | B>, this);\r\n  }\r\n}\r\n","import { AbortablePromise } from './AbortablePromise.js';\r\nimport type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\n\r\nfunction assignResolve<P extends ManualPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: ManualPromise<any>,\r\n): P {\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class ManualPromise<T> extends AbortablePromise<T> {\r\n  /**\r\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): ManualPromise<T> {\r\n    return new ManualPromise((res, rej, signal) => {\r\n      try {\r\n        Promise.resolve(fn(signal)).then(res, rej);\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): ManualPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): ManualPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): ManualPromise<Awaited<T>> {\r\n    return this.fn(() => value) as ManualPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any,): ManualPromise<T> {\r\n    return new ManualPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new ManualPromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new ManualPromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<T>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<T> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let executor: PromiseExecutorFn<T> | undefined;\r\n    let options: PromiseOptions | undefined;\r\n\r\n    if (typeof executorOrOptions === 'function') {\r\n      executor = executorOrOptions;\r\n      options = maybeOptions;\r\n    } else {\r\n      options = executorOrOptions;\r\n    }\r\n\r\n    let resolve!: PromiseResolveFn<T>;\r\n    super((res, rej, context) => {\r\n      resolve = res;\r\n      executor && executor(res, rej, context);\r\n    }, options);\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): ManualPromise<T | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): ManualPromise<T> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.finally.\r\n    return assignResolve(super.finally(onFinally) as ManualPromise<T>, this);\r\n  }\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: PromiseResolveFn<T>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = T, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<T, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): ManualPromise<A | B> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.then.\r\n    return assignResolve(super.then(onFulfilled, onRejected) as ManualPromise<A | B>, this);\r\n  }\r\n}"],"names":["f","u","c","a","p","n","i","o","CancelledError","isCancelledError","errorClass","TimeoutError","isTimeoutError","timeout","cause","RESOLVED_SYMBOL","isPromiseResolveResult","value","withResolved","reassignProps","childPromise","parentPromise","AbortablePromise","executorOrOptions","maybeOptions","reject","abort","res","rej","executor","options","cleanupFns","withCleanup","fn","args","result","controller","signal","reason","abortReason","onAborted","listener","wrapped","cleanup","resolve","abortSignal","rejectOnAbort","timeoutId","isAborted","isResolved","resolved","e","__publicField","context","_","onRejected","onFinally","onFulfilled","assignResolve","ManualPromise"],"mappings":"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","x_google_ignoreList":[0]}