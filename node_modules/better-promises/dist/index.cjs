"use strict";var Y=Object.defineProperty;var $=(r,t,e)=>t in r?Y(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var m=(r,t,e)=>$(r,typeof t!="symbol"?t+"":t,e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});var k=Object.defineProperty,q=(r,t,e)=>t in r?k(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,z=(r,t,e)=>q(r,t+"",e);function G(r,t){return e=>e instanceof r&&e.type===t}function M(r,t){t||(t=[]);const e=Symbol(r);class c extends Error{constructor(...s){const i=typeof t=="function"?t(...s):typeof t=="string"?[t]:t||[];super(...i),z(this,"type",e),this.name=r}}return Object.defineProperty(c,"name",{value:r}),[c,G(c,e)]}const[x,H]=M("CancelledError","Promise was canceled"),[B,J]=M("TimeoutError",(r,t)=>[`Timeout reached: ${r}ms`,{cause:t}]),D=Symbol("Resolved");function g(r){return Array.isArray(r)&&r[0]===D}function K(r){return[D,r]}function P(r,t){return r.reject=t.reject,r.abort=t.abort,r}class v extends Promise{constructor(e,c){let o,s;super((i,a)=>{let b,l;typeof e=="function"?(b=e,l=c):l=e;const p=[],j=n=>(...h)=>{const y=n(...h);return p.forEach(V=>V()),y},T=new AbortController,{signal:u}=T;s=n=>{!u.aborted&&T.abort(n)};const d=()=>u.reason,w=n=>{const h=()=>{n(d())};u.addEventListener("abort",h,!0);const y=()=>{u.removeEventListener("abort",h,!0)};return p.push(y),y},F=j(n=>{i(n),s(K(n))});o=j(n=>{a(n),s(n)}),l||(l={});const{abortSignal:f,rejectOnAbort:S=!0}=l;if(f)if(f.aborted){const{reason:n}=f;if(S)return o(n);s(n)}else{const n=()=>{s(f.reason)};f.addEventListener("abort",n),p.push(()=>{f.removeEventListener("abort",n)})}S&&w(a);const{timeout:R}=l;if(R){const n=setTimeout(()=>{s(new B(R))},R);p.push(()=>{clearTimeout(n)})}const A=()=>u.aborted,C=()=>g(d()),L=()=>{const n=d();return g(n)?n[1]:void 0};try{const n=b&&b(F,o,{abortReason:d,abortSignal:u,isAborted:A,isResolved:C,onAborted:w,onResolved:h=>w(()=>{C()&&h(L())}),resolved:L,throwIfAborted(){if(A())throw d()}});n instanceof Promise&&n.catch(o)}catch(n){o(n)}});m(this,"abort");m(this,"reject");this.abort=s,this.reject=o}static fn(e,c){return new v(async(o,s,i)=>{try{o(await e(i))}catch(a){s(a)}},c)}static resolve(e){return this.fn(()=>e)}static reject(e){return new v((c,o)=>{o(e)})}cancel(){this.abort(new x)}catch(e){return this.then(void 0,e)}finally(e){return P(super.finally(e),this)}then(e,c){return P(super.then(e,c),this)}}function I(r,t){return r.resolve=t.resolve,r}class E extends v{constructor(e,c){let o,s;typeof e=="function"?(o=e,s=c):s=e;let i;super((a,b,l)=>{i=a,o&&o(a,b,l)},s);m(this,"resolve");this.resolve=i}static fn(e,c){return new E((o,s,i)=>{try{Promise.resolve(e(i)).then(o,s)}catch(a){s(a)}},c)}static resolve(e){return this.fn(()=>e)}static reject(e){return new E((c,o)=>{o(e)})}catch(e){return this.then(void 0,e)}finally(e){return I(super.finally(e),this)}then(e,c){return I(super.then(e,c),this)}}exports.AbortablePromise=v;exports.CancelledError=x;exports.ManualPromise=E;exports.TimeoutError=B;exports.isCancelledError=H;exports.isPromiseResolveResult=g;exports.isTimeoutError=J;
//# sourceMappingURL=index.cjs.map
