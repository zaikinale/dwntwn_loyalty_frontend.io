var betterPromises=function(i){"use strict";var N=Object.defineProperty;var Q=(i,l,h)=>l in i?N(i,l,{enumerable:!0,configurable:!0,writable:!0,value:h}):i[l]=h;var g=(i,l,h)=>Q(i,typeof l!="symbol"?l+"":l,h);var l=Object.defineProperty,h=(r,n,e)=>n in r?l(r,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[n]=e,k=(r,n,e)=>h(r,n+"",e);function q(r,n){return e=>e instanceof r&&e.type===n}function A(r,n){n||(n=[]);const e=Symbol(r);class c extends Error{constructor(...s){const a=typeof n=="function"?n(...s):typeof n=="string"?[n]:n||[];super(...a),k(this,"type",e),this.name=r}}return Object.defineProperty(c,"name",{value:r}),[c,q(c,e)]}const[C,z]=A("CancelledError","Promise was canceled"),[P,G]=A("TimeoutError",(r,n)=>[`Timeout reached: ${r}ms`,{cause:n}]),L=Symbol("Resolved");function j(r){return Array.isArray(r)&&r[0]===L}function H(r){return[L,r]}function I(r,n){return r.reject=n.reject,r.abort=n.abort,r}class m extends Promise{constructor(e,c){let o,s;super((a,u)=>{let y,f;typeof e=="function"?(y=e,f=c):f=e;const w=[],B=t=>(...d)=>{const R=t(...d);return w.forEach(K=>K()),R},D=new AbortController,{signal:b}=D;s=t=>{!b.aborted&&D.abort(t)};const E=()=>b.reason,T=t=>{const d=()=>{t(E())};b.addEventListener("abort",d,!0);const R=()=>{b.removeEventListener("abort",d,!0)};return w.push(R),R},J=B(t=>{a(t),s(H(t))});o=B(t=>{u(t),s(t)}),f||(f={});const{abortSignal:v,rejectOnAbort:F=!0}=f;if(v)if(v.aborted){const{reason:t}=v;if(F)return o(t);s(t)}else{const t=()=>{s(v.reason)};v.addEventListener("abort",t),w.push(()=>{v.removeEventListener("abort",t)})}F&&T(u);const{timeout:S}=f;if(S){const t=setTimeout(()=>{s(new P(S))},S);w.push(()=>{clearTimeout(t)})}const V=()=>b.aborted,Y=()=>j(E()),$=()=>{const t=E();return j(t)?t[1]:void 0};try{const t=y&&y(J,o,{abortReason:E,abortSignal:b,isAborted:V,isResolved:Y,onAborted:T,onResolved:d=>T(()=>{Y()&&d($())}),resolved:$,throwIfAborted(){if(V())throw E()}});t instanceof Promise&&t.catch(o)}catch(t){o(t)}});g(this,"abort");g(this,"reject");this.abort=s,this.reject=o}static fn(e,c){return new m(async(o,s,a)=>{try{o(await e(a))}catch(u){s(u)}},c)}static resolve(e){return this.fn(()=>e)}static reject(e){return new m((c,o)=>{o(e)})}cancel(){this.abort(new C)}catch(e){return this.then(void 0,e)}finally(e){return I(super.finally(e),this)}then(e,c){return I(super.then(e,c),this)}}function M(r,n){return r.resolve=n.resolve,r}class p extends m{constructor(e,c){let o,s;typeof e=="function"?(o=e,s=c):s=e;let a;super((u,y,f)=>{a=u,o&&o(u,y,f)},s);g(this,"resolve");this.resolve=a}static fn(e,c){return new p((o,s,a)=>{try{Promise.resolve(e(a)).then(o,s)}catch(u){s(u)}},c)}static resolve(e){return this.fn(()=>e)}static reject(e){return new p((c,o)=>{o(e)})}catch(e){return this.then(void 0,e)}finally(e){return M(super.finally(e),this)}then(e,c){return M(super.then(e,c),this)}}return i.AbortablePromise=m,i.CancelledError=C,i.ManualPromise=p,i.TimeoutError=P,i.isCancelledError=z,i.isPromiseResolveResult=j,i.isTimeoutError=G,Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),i}({});
//# sourceMappingURL=index.iife.js.map
