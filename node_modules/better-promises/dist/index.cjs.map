{"version":3,"file":"index.cjs","sources":["../node_modules/.pnpm/error-kid@0.0.7/node_modules/error-kid/dist/index.js","../src/errors/CancelledError.ts","../src/errors/TimeoutError.ts","../src/promises/resolve.ts","../src/promises/AbortablePromise.ts","../src/promises/ManualPromise.ts"],"sourcesContent":["var f = Object.defineProperty;\nvar u = (r, t, e) => t in r ? f(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar c = (r, t, e) => u(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction a(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction p(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class n extends Error {\n    constructor(...i) {\n      const o = typeof t == \"function\" ? t(...i) : typeof t == \"string\" ? [t] : t || [];\n      super(...o);\n      c(this, \"type\", e);\n      this.name = r;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: r }), [n, a(n, e)];\n}\nfunction l(r, t, e) {\n  const n = Symbol(r);\n  class s extends p(r, e)[0] {\n    constructor(...o) {\n      super(...o);\n      c(this, \"data\");\n      c(this, \"type\", n);\n      this.data = t(...o);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: r }), [s, a(s, n)];\n}\nexport {\n  p as errorClass,\n  l as errorClassWithData,\n  a as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\r\n\r\nexport const [CancelledError, isCancelledError] =\r\n  errorClass('CancelledError', 'Promise was canceled');","import { errorClass } from 'error-kid';\r\n\r\nexport const [TimeoutError, isTimeoutError] =\r\n  errorClass<[timeout: number, cause?: unknown]>(\r\n    'TimeoutError',\r\n    (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n  );\r\n","export type PromiseResolveResult<T> = [typeof RESOLVED_SYMBOL, T];\r\n\r\nconst RESOLVED_SYMBOL = Symbol('Resolved');\r\n\r\n/**\r\n * @return True if passed value determines that the promise was resolved.\r\n * @param value\r\n * @example\r\n * const promise = new ManualPromise(async (res, rej, signal) => {\r\n *   // Imitate something async here.\r\n *   await new Promise(res => setTimeout(res, 1000));\r\n *\r\n *   if (isResolved(signal.reason)) {\r\n *     // It means that ManualPromise was resolved outside. We probably want to stop executing\r\n *     // the function as long as the result will not affect anything.\r\n *     return;\r\n *   }\r\n *\r\n *   // Otherwise keep doing what we do.\r\n * });\r\n */\r\nexport function isPromiseResolveResult(value: unknown): value is PromiseResolveResult<unknown> {\r\n  return Array.isArray(value) && value[0] === RESOLVED_SYMBOL;\r\n}\r\n\r\nexport function withResolved<T>(value: T): PromiseResolveResult<T> {\r\n  return [RESOLVED_SYMBOL, value];\r\n}","import type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseRejectFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\nimport { TimeoutError } from '../errors/TimeoutError.js';\r\nimport { CancelledError } from '../errors/CancelledError.js';\r\nimport { isPromiseResolveResult, withResolved } from './resolve.js';\r\n\r\nfunction reassignProps<P extends AbortablePromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: AbortablePromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.abort = parentPromise.abort;\r\n  return childPromise;\r\n}\r\n\r\n/**\r\n * Improved version of the JavaScript Promise.\r\n */\r\nexport class AbortablePromise<Result> extends Promise<Result> {\r\n  /**\r\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): AbortablePromise<T> {\r\n    return new AbortablePromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): AbortablePromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): AbortablePromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): AbortablePromise<Awaited<T>> {\r\n    return this.fn(() => value) as AbortablePromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any): AbortablePromise<T> {\r\n    return new AbortablePromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new AbortablePromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new AbortablePromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<Result>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<Result> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let reject!: PromiseRejectFn;\r\n    let abort!: (reason: unknown) => void;\r\n    super((res, rej) => {\r\n      let executor: PromiseExecutorFn<Result> | undefined;\r\n      let options: PromiseOptions | undefined;\r\n\r\n      if (typeof executorOrOptions === 'function') {\r\n        executor = executorOrOptions;\r\n        options = maybeOptions;\r\n      } else {\r\n        options = executorOrOptions;\r\n      }\r\n\r\n      //#region Cleanup section.\r\n      const cleanupFns: VoidFunction[] = [];\r\n      const withCleanup = <F extends (...args: any) => any>(\r\n        fn: F,\r\n      ): (...args: Parameters<F>) => ReturnType<F> => {\r\n        return (...args) => {\r\n          const result = fn(...args);\r\n          cleanupFns.forEach(fn => fn());\r\n          return result;\r\n        };\r\n      };\r\n      //#endregion\r\n\r\n      // We are going to use our controller signal in the executor because we can control it.\r\n      // We can't say the same about the abort signal passed from above, we can't abort it by\r\n      // ourselves.\r\n      const controller = new AbortController();\r\n      const { signal } = controller;\r\n      abort = reason => {\r\n        !signal.aborted && controller.abort(reason);\r\n      };\r\n      const abortReason = () => signal.reason;\r\n      const onAborted = (listener: (reason: unknown) => void): VoidFunction => {\r\n        const wrapped = () => {\r\n          listener(abortReason());\r\n        };\r\n        signal.addEventListener('abort', wrapped, true);\r\n\r\n        const cleanup = () => {\r\n          signal.removeEventListener('abort', wrapped, true);\r\n        };\r\n        cleanupFns.push(cleanup);\r\n        return cleanup;\r\n      };\r\n\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const resolve = withCleanup((result: Result) => {\r\n        res(result);\r\n        abort(withResolved(result));\r\n      }) as PromiseResolveFn<Result>;\r\n      reject = withCleanup(reason => {\r\n        rej(reason);\r\n        abort(reason);\r\n      });\r\n\r\n      //#region Process abortSignal option.\r\n      options ||= {};\r\n      const { abortSignal, rejectOnAbort = true } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          const { reason } = abortSignal;\r\n          if (rejectOnAbort) {\r\n            return reject(reason);\r\n          }\r\n          abort(reason);\r\n        } else {\r\n          // When the passed abort signal aborts, we are also aborting our locally created signal.\r\n          const listener = () => {\r\n            abort(abortSignal.reason);\r\n          };\r\n          abortSignal.addEventListener('abort', listener);\r\n          cleanupFns.push(() => {\r\n            abortSignal.removeEventListener('abort', listener);\r\n          });\r\n        }\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process rejectOnAbort option.\r\n      rejectOnAbort && onAborted(rej);\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          abort(new TimeoutError(timeout));\r\n        }, timeout);\r\n\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      const isAborted = () => signal.aborted;\r\n      const isResolved = () => isPromiseResolveResult(abortReason());\r\n      const resolved = () => {\r\n        const reason = abortReason();\r\n        return isPromiseResolveResult(reason) ? reason[1] as Result : undefined;\r\n      };\r\n      try {\r\n        const result = executor && executor(resolve, reject, {\r\n          abortReason,\r\n          abortSignal: signal,\r\n          isAborted,\r\n          isResolved,\r\n          onAborted,\r\n          onResolved: listener => onAborted(() => {\r\n            isResolved() && listener(resolved() as Result);\r\n          }),\r\n          resolved,\r\n          throwIfAborted() {\r\n            if (isAborted()) {\r\n              throw abortReason();\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.abort = abort;\r\n    this.reject = reject;\r\n  }\r\n\r\n  /**\r\n   * Aborts the promise execution using the specified reason.\r\n   *\r\n   * Not that this method doesn't reject the promise but notifies the executor using its context.\r\n   * To perform the same operation but also reject the promise, use the `reject()` method.\r\n   * @param reason - abort reason.\r\n   * @see reject\r\n   */\r\n  abort: (reason?: unknown) => void;\r\n\r\n  /**\r\n   * Aborts the promise with the cancel error.\r\n   */\r\n  cancel(): void {\r\n    this.abort(new CancelledError())\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): AbortablePromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): AbortablePromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return reassignProps(super.finally(onFinally) as AbortablePromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: PromiseRejectFn;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): AbortablePromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return reassignProps(super.then(onFulfilled, onRejected) as AbortablePromise<A | B>, this);\r\n  }\r\n}\r\n","import { AbortablePromise } from './AbortablePromise.js';\r\nimport type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\n\r\nfunction assignResolve<P extends ManualPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: ManualPromise<any>,\r\n): P {\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class ManualPromise<T> extends AbortablePromise<T> {\r\n  /**\r\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): ManualPromise<T> {\r\n    return new ManualPromise((res, rej, signal) => {\r\n      try {\r\n        Promise.resolve(fn(signal)).then(res, rej);\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): ManualPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): ManualPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): ManualPromise<Awaited<T>> {\r\n    return this.fn(() => value) as ManualPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any,): ManualPromise<T> {\r\n    return new ManualPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new ManualPromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new ManualPromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<T>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<T> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let executor: PromiseExecutorFn<T> | undefined;\r\n    let options: PromiseOptions | undefined;\r\n\r\n    if (typeof executorOrOptions === 'function') {\r\n      executor = executorOrOptions;\r\n      options = maybeOptions;\r\n    } else {\r\n      options = executorOrOptions;\r\n    }\r\n\r\n    let resolve!: PromiseResolveFn<T>;\r\n    super((res, rej, context) => {\r\n      resolve = res;\r\n      executor && executor(res, rej, context);\r\n    }, options);\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): ManualPromise<T | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): ManualPromise<T> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.finally.\r\n    return assignResolve(super.finally(onFinally) as ManualPromise<T>, this);\r\n  }\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: PromiseResolveFn<T>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = T, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<T, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): ManualPromise<A | B> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.then.\r\n    return assignResolve(super.then(onFulfilled, onRejected) as ManualPromise<A | B>, this);\r\n  }\r\n}"],"names":["f","u","c","a","p","n","i","o","CancelledError","isCancelledError","errorClass","TimeoutError","isTimeoutError","timeout","cause","RESOLVED_SYMBOL","isPromiseResolveResult","value","withResolved","reassignProps","childPromise","parentPromise","AbortablePromise","executorOrOptions","maybeOptions","reject","abort","res","rej","executor","options","cleanupFns","withCleanup","fn","args","result","controller","signal","reason","abortReason","onAborted","listener","wrapped","cleanup","resolve","abortSignal","rejectOnAbort","timeoutId","isAborted","isResolved","resolved","e","__publicField","context","_","onRejected","onFinally","onFulfilled","assignResolve","ManualPromise"],"mappings":"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","x_google_ignoreList":[0]}