import { setDebug as ln, invokeCustomMethod as pn, retrieveLaunchParams as wo, createPostEvent as dn, request as mn, postEvent as _n, supports as oe, isTMA as Jt, on as m, off as E, retrieveRawInitData as fn, captureSameReq as hn } from "@telegram-apps/bridge";
import { AbortablePromise as Yl, CancelledError as Xl, InvalidLaunchParamsError as Zl, InvokeCustomMethodError as Jl, LaunchParamsRetrieveError as ep, ManualPromise as tp, MethodParameterUnsupportedError as op, MethodUnsupportedError as sp, TimeoutError as np, UnknownEnvError as rp, applyPolyfills as ap, logger as ip, createPostEvent as cp, createStartParam as up, decodeBase64Url as lp, decodeStartParam as pp, emitEvent as dp, encodeBase64Url as mp, isCancelledError as _p, isInvalidLaunchParamsError as fp, isInvokeCustomMethodError as hp, isLaunchParamsRetrieveError as bp, isMethodMethodParameterUnsupportedError as gp, isMethodUnsupportedError as Ep, isSafeToCreateStartParam as Sp, isTMA as Cp, isTimeoutError as wp, isUnknownEnvError as $p, mockTelegramEnv as Mp, off as Ap, on as vp, postMessage as yp, postMessageImplementation as Bp, retrieveLaunchParams as Pp, retrieveRawInitData as Tp, retrieveRawLaunchParams as kp, supports as Op, targetOrigin as Ip } from "@telegram-apps/bridge";
import { createLogger as bn, getStorageValue as S, setStorageValue as M, snakeToKebab as gn, createCbCollector as tt, camelToKebab as $o } from "@telegram-apps/toolkit";
import { createLogger as qp } from "@telegram-apps/toolkit";
import { isPageReload as C } from "@telegram-apps/navigation";
import { computed as En, signal as Mo, batch as se } from "@telegram-apps/signals";
import { errorClass as A } from "error-kid";
import { AbortablePromise as f, isCancelledError as Sn, ManualPromise as Cn } from "better-promises";
import { parse as ne, array as wn, string as $, record as $n, ValiError as eo, pipe as fe, union as Mn, instance as An, looseObject as to, transform as Ao, date as vo, optional as vn, number as yo, integer as yn } from "valibot";
import { toRGB as Bn, isRGB as Ce, transformQueryUsing as Pn, jsonParse as Tn } from "@telegram-apps/transformers";
import { isRGB as Dp, isRGBShort as Np, parseInitDataQuery as Hp, parseLaunchParamsQuery as Lp, serializeInitDataQuery as Rp, serializeLaunchParamsQuery as jp, serializeToQuery as Fp, toRGB as Up, transformQueryUsing as Gp } from "@telegram-apps/transformers";
// @__NO_SIDE_EFFECTS__
function z(e, t) {
  return Mo(e, t);
}
// @__NO_SIDE_EFFECTS__
function c(e, t) {
  return En(e, t);
}
// @__NO_SIDE_EFFECTS__
function u(e, t) {
  const o = /* @__PURE__ */ z(e, t);
  return [o, /* @__PURE__ */ c(o)];
}
let Bo = !1;
function Tu(e) {
  Bo = e, ln(e);
}
const Qe = Mo(bn("Bridge", {
  bgColor: "forestgreen",
  textColor: "white",
  shouldLog() {
    return Bo;
  }
})), je = /* @__PURE__ */ z(0), Po = /* @__PURE__ */ z(_n), [oo, le] = /* @__PURE__ */ u({
  tgWebAppPlatform: "unknown",
  tgWebAppVersion: "0.0"
}), O = /* @__PURE__ */ c(() => le().tgWebAppVersion);
function kn(e) {
  e || (e = {});
  const { postEvent: t } = e, o = e.launchParams || wo();
  oo.set(o), Po.set(
    typeof t == "function" ? t : dn(o.tgWebAppVersion)
  ), Qe().log("The package was configured. Launch params:", oo());
}
function To() {
  return je.set(je() + 1), je().toString();
}
function W(e, t, o) {
  return pn(e, t, To(), {
    ...o || {},
    postEvent: i
  });
}
const d = (e, t, o) => (o || (o = {}), o.postEvent || (o.postEvent = i), mn(e, t, o)), i = (e, t) => Po()(e, t);
function v(e) {
  return /* @__PURE__ */ c(() => oe(e, O()));
}
function L(e) {
  return [e];
}
const [
  ot,
  ku
] = A("CSSVarsBoundError", "CSS variables are already bound"), [
  ko,
  Ou
] = A("NotAvailableError", L), [
  Iu,
  Vu
] = A("InvalidEnvError", L), [
  Z,
  qu
] = A("FunctionNotAvailableError", L), [
  y,
  xu
] = A(
  "InvalidArgumentsError",
  (e, t) => [e, { cause: t }]
), [
  On,
  Du
] = A("ConcurrentCallError", L), [
  In,
  Nu
] = A(
  "SetEmojiStatusError",
  (e) => [`Failed to set emoji status: ${e}`]
), [
  Oo,
  Hu
] = A("AccessDeniedError", L), [
  Vn,
  Lu
] = A("FullscreenFailedError", L), [
  qn,
  Ru
] = A("ShareMessageError", L), [
  st,
  ju
] = A("UnknownThemeParamsKeyError", (e) => [`Unknown theme params key passed: ${e}`]);
function so() {
  return typeof window > "u";
}
// @__NO_SIDE_EFFECTS__
function p(e, t, o) {
  o || (o = {});
  const {
    isSupported: s,
    isMounted: n,
    isMounting: r,
    component: a,
    supports: l
  } = o || {}, P = `${a ? `${a}.` : ""}${e}()`, T = s ? Array.isArray(s) || typeof s == "object" && "any" in s ? s : [s] : void 0;
  function X(g) {
    if (l) {
      const _ = l[g];
      return oe(_[0], _[1], O());
    }
    return !0;
  }
  function k() {
    if (!T)
      return;
    function g(U) {
      return typeof U == "function" ? U() : oe(U, O()) ? void 0 : `it is unsupported in Mini Apps version ${O()}`;
    }
    const _ = Array.isArray(T) ? T : T.any, x = _.map(g).filter(Boolean);
    return Array.isArray(T) ? x[0] : x.length === _.length ? x[x.length - 1] : void 0;
  }
  function cn(...g) {
    for (const _ in l)
      if (l[_][2](...g) && !X(_))
        return `option ${_} is not supported in Mini Apps version ${O()}`;
  }
  let _e;
  if (l) {
    _e = {};
    for (const g in l)
      _e[g] = /* @__PURE__ */ c(() => X(g));
  }
  const Kt = /* @__PURE__ */ c(() => !k()), Yt = /* @__PURE__ */ c(() => O() !== "0.0"), Xt = /* @__PURE__ */ c(() => !n || n()), Zt = /* @__PURE__ */ c(
    () => Jt() && !so() && Yt() && Kt() && Xt()
  );
  return Object.assign(
    (...g) => {
      const _ = `Unable to call the ${P} ${a ? "method" : "function"}:`;
      if (so() || !Jt())
        throw new Z(`${_} it can't be called outside Mini Apps`);
      if (!Yt())
        throw new Z(`${_} the SDK was not initialized. Use the SDK init() function`);
      const x = k();
      if (x)
        throw new Z(`${_} ${x}`);
      const U = cn(...g);
      if (U)
        throw new Z(`${_} ${U}`);
      if (!Xt()) {
        const un = r && r() ? "mounting. Wait for the mount completion" : `unmounted. Use the ${a}.mount() method`;
        throw new Z(`${_} the component is ${un}`);
      }
      return t(...g);
    },
    t,
    {
      isAvailable: Zt,
      ifAvailable(...g) {
        return Zt() ? [!0, t(...g)] : [!1];
      }
    },
    T ? { isSupported: Kt } : {},
    _e ? { supports: _e } : {}
  );
}
function we(e, t) {
  return t || (t = {}), (o, s, n, r) => /* @__PURE__ */ p(o, s, {
    ...t,
    isSupported: n || t.isSupported,
    supports: r,
    component: e
  });
}
function I(e, t, o) {
  return we(e, { isSupported: o, isMounted: t });
}
function w(e, t) {
  return we(e, { isSupported: t });
}
const $e = "web_app_setup_back_button", Io = "back_button_pressed", Me = "backButton", [no, xn] = /* @__PURE__ */ u(!1), [he, Dn] = /* @__PURE__ */ u(!1), Nn = v($e), Vo = I(Me, he, $e), nt = w(Me, $e), Hn = Vo("hide", () => {
  rt(!1);
}), Ln = nt("mount", () => {
  he() || (rt(C() && S(Me) || !1), he.set(!0));
});
function rt(e) {
  e !== no() && (i($e, { is_visible: e }), M(Me, e), no.set(e));
}
const Rn = nt(
  "onClick",
  (e) => m(Io, e)
), jn = nt(
  "offClick",
  (e) => {
    E(Io, e);
  }
), Fn = Vo("show", () => {
  rt(!0);
});
function Un() {
  he.set(!1);
}
const Fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: Hn,
  isMounted: Dn,
  isSupported: Nn,
  isVisible: xn,
  mount: Ln,
  offClick: jn,
  onClick: Rn,
  show: Fn,
  unmount: Un
}, Symbol.toStringTag, { value: "Module" }));
function b(e, t, o) {
  o || (o = {});
  const {
    promise: s,
    error: n
  } = o, [r, a] = s ? [s, /* @__PURE__ */ c(s)] : /* @__PURE__ */ u(), [l, P] = n ? [n, /* @__PURE__ */ c(n)] : /* @__PURE__ */ u();
  return [
    Object.assign((...T) => {
      if (r()) {
        const k = new On(t);
        return l.set(k), f.reject(k);
      }
      se(() => {
        r.set(e(...T)), l.set(void 0);
      });
      let X;
      return r().catch((k) => {
        throw X = k, k;
      }).finally(() => {
        se(() => {
          r.set(void 0), l.set(X);
        });
      });
    }, e),
    [r, a, /* @__PURE__ */ c(() => !!r())],
    [l, P]
  ];
}
// @__NO_SIDE_EFFECTS__
function pe(e, t, o) {
  const [s, ...n] = b(t, `The ${e} component is already mounting`), [r, a] = /* @__PURE__ */ u(!1);
  return [
    (...l) => r() ? f.resolve() : s(...l).then((P) => {
      se(() => {
        r.set(!0), o(P);
      });
    }),
    ...n,
    [r, a]
  ];
}
const [at, Gn] = /* @__PURE__ */ u({
  available: !1,
  type: "",
  accessGranted: !1,
  accessRequested: !1,
  deviceId: "",
  tokenSaved: !1
}), zn = /* @__PURE__ */ c(() => at().available), ro = "web_app_biometry_get_info", Wn = /* @__PURE__ */ p(
  "requestBiometry",
  (e) => d(ro, "biometry_info_received", e),
  { isSupported: ro }
);
function qo(e) {
  if (!Sn(e))
    throw e;
}
function Q(e) {
  const t = e();
  t && t.catch(qo).cancel();
}
const re = "biometry", Ae = "web_app_biometry_request_auth", it = "biometry_info_received", xo = (e) => {
  ve(ct(e));
};
function Do() {
  throw new ko("Biometry is not available");
}
function ct(e) {
  let t = !1, o = !1, s = "", n = !1, r = "", a = !1;
  return e.available && (t = !0, o = e.token_saved, s = e.device_id, n = e.access_requested, r = e.type, a = e.access_granted), { available: t, tokenSaved: o, deviceId: s, type: r, accessGranted: a, accessRequested: n };
}
const Qn = v(Ae), [
  Kn,
  Yn,
  Xn,
  No
] = /* @__PURE__ */ pe(
  re,
  (e) => {
    const t = C() && S(re);
    return t ? f.resolve(t) : Wn({ abortSignal: e }).then(ct);
  },
  (e) => {
    m(it, xo), ve(e);
  }
), Ho = w(re, Ae), ut = I(re, No[0], Ae), Zn = Ho("mount", Kn), [, Lo, Jn] = Yn, [, er] = Xn, [tr, or] = No, [
  sr,
  nr,
  rr
] = b(
  (e) => f.fn(async (t) => {
    const o = at();
    o.available || Do();
    const s = await d(Ae, "biometry_auth_requested", {
      ...e,
      ...t,
      params: { reason: ((e || {}).reason || "").trim() }
    }), { token: n } = s;
    return typeof n == "string" && ve({ ...o, token: n }), s;
  }, e),
  "Biometry authentication is already in progress"
), ar = ut("authenticate", sr), [, Ro, ir] = nr, [, cr] = rr, ur = Ho("openSettings", () => {
  i("web_app_biometry_open_settings");
}), [
  lr,
  pr,
  dr
] = b(
  (e) => f.fn(async (t) => {
    const o = await d("web_app_biometry_request_access", it, {
      ...e,
      ...t,
      params: { reason: (e || {}).reason || "" }
    }).then(ct);
    return o.available || Do(), ve(o), o.accessGranted;
  }, e),
  "Biometry access request is already in progress"
), mr = ut("requestAccess", lr), [, jo, _r] = pr, [, fr] = dr;
function ve(e) {
  at.set(e), M(re, e);
}
function hr() {
  [Ro, jo, Lo].forEach(Q), E(it, xo), tr.set(!1);
}
const br = ut(
  "updateToken",
  (e) => (e || (e = {}), d("web_app_biometry_update_token", "biometry_token_updated", {
    ...e,
    params: {
      token: e.token || "",
      reason: e.reason
    }
  }).then((t) => t.status))
), Uu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authError: cr,
  authPromise: Ro,
  authenticate: ar,
  isAuthenticating: ir,
  isAvailable: zn,
  isMounted: or,
  isMounting: Jn,
  isRequestingAccess: _r,
  isSupported: Qn,
  mount: Zn,
  mountError: er,
  mountPromise: Lo,
  openSettings: ur,
  requestAccess: mr,
  requestAccessError: fr,
  requestAccessPromise: jo,
  state: Gn,
  unmount: hr,
  updateToken: br
}, Symbol.toStringTag, { value: "Module" }));
function ye(e, t) {
  return we(e, { isMounted: t });
}
const V = we, Be = "closingBehavior", [ao, gr] = /* @__PURE__ */ u(!1), [Ke, Fo] = /* @__PURE__ */ u(!1), Uo = ye(Be, Fo), Er = V(Be), Sr = Uo("disableConfirmation", () => {
  lt(!1);
}), Cr = Uo("enableConfirmation", () => {
  lt(!0);
}), wr = Er("mount", () => {
  Ke() || (lt(
    C() && S(Be) || !1
  ), Ke.set(!0));
});
function lt(e) {
  e !== ao() && (i("web_app_setup_closing_behavior", { need_confirmation: e }), M(Be, e), ao.set(e));
}
function $r() {
  Ke.set(!1);
}
const Gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableConfirmation: Sr,
  enableConfirmation: Cr,
  isConfirmationEnabled: gr,
  isMounted: Fo,
  mount: wr,
  unmount: $r
}, Symbol.toStringTag, { value: "Module" })), Go = "web_app_invoke_custom_method", de = w("cloudStorage", Go), Mr = v(Go), zo = de("deleteItem", (e, t) => {
  const o = Array.isArray(e) ? e : [e];
  return o.length ? W("deleteStorageValues", { keys: o }, t).then() : f.resolve();
});
function Ar(e, t) {
  const o = Array.isArray(e) ? e : [e];
  return o.length ? W("getStorageValues", { keys: o }, t).then((s) => {
    const n = {
      // Fulfill the response with probably missing keys.
      ...o.reduce((r, a) => (r[a] = "", r), {}),
      ...ne($n($(), $()), s)
    };
    return typeof e == "string" ? n[e] : n;
  }) : f.resolve(Array.isArray(e) ? {} : "");
}
const vr = de("getItem", Ar), Wo = de("getKeys", (e) => W("getStorageKeys", {}, e).then(
  (t) => ne(wn($()), t)
)), yr = de("setItem", (e, t, o) => W("saveStorageValue", {
  key: e,
  value: t
}, o).then()), Br = de("clear", (e) => Wo(e).then(zo)), zu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clear: Br,
  deleteItem: zo,
  getItem: vr,
  getKeys: Wo,
  isSupported: Mr,
  setItem: yr
}, Symbol.toStringTag, { value: "Module" })), me = "web_app_trigger_haptic_feedback", pt = w("hapticFeedback", me), Pr = v(me), Tr = pt(
  "impactOccurred",
  (e) => {
    i(me, {
      type: "impact",
      impact_style: e
    });
  }
), kr = pt(
  "notificationOccurred",
  (e) => {
    i(me, {
      type: "notification",
      notification_type: e
    });
  }
), Or = pt(
  "selectionChanged",
  () => {
    i(me, { type: "selection_change" });
  }
), Wu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  impactOccurred: Tr,
  isSupported: Pr,
  notificationOccurred: kr,
  selectionChanged: Or
}, Symbol.toStringTag, { value: "Module" })), [Qo, Ir] = /* @__PURE__ */ u(void 0);
function B(e) {
  return /* @__PURE__ */ c(() => {
    const t = Qo();
    return t ? t[e] : void 0;
  });
}
const Ko = B("auth_date"), Yo = B("can_send_after"), Vr = /* @__PURE__ */ c(() => {
  const e = Ko(), t = Yo();
  return t && e ? new Date(e.getTime() + t * 1e3) : void 0;
}), qr = B("chat"), xr = B("chat_type"), Dr = B("chat_instance"), Nr = B("hash"), Hr = B("query_id"), [Lr, Rr] = /* @__PURE__ */ u(), jr = B("receiver");
function Fr() {
  const e = wo();
  Qo.set(e.tgWebAppData), Lr.set(fn());
}
const Ur = B("start_param"), Gr = B("user"), Qu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authDate: Ko,
  canSendAfter: Yo,
  canSendAfterDate: Vr,
  chat: qr,
  chatInstance: Dr,
  chatType: xr,
  hash: Nr,
  queryId: Hr,
  raw: Rr,
  receiver: jr,
  restore: Fr,
  startParam: Ur,
  state: Ir,
  user: Gr
}, Symbol.toStringTag, { value: "Module" })), dt = "web_app_open_invoice", zr = w("invoice", dt), Wr = v(dt);
function Qr(e, t, o) {
  let s;
  if (t === "url") {
    const { hostname: n, pathname: r } = new URL(e, window.location.href);
    if (n !== "t.me")
      throw new y(`Link has unexpected hostname: ${n}`);
    const a = r.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new y(
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , s] = a;
  } else
    s = e, o = t;
  return d(dt, "invoice_closed", {
    ...o,
    params: { slug: s },
    capture: (n) => s === n.slug
  }).then((n) => n.status);
}
const [
  Kr,
  Yr,
  Xr
] = b(Qr, "Invoice is already opened"), Zr = zr("open", Kr), [, Jr, ea] = Yr, [, ta] = Xr, Ku = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: ea,
  isSupported: Wr,
  open: Zr,
  openError: ta,
  openPromise: Jr
}, Symbol.toStringTag, { value: "Module" })), J = "locationManager", mt = "web_app_check_location", io = "web_app_open_location_settings", be = /* @__PURE__ */ z({
  available: !1,
  accessGranted: !1,
  accessRequested: !1
});
function _t(e) {
  return /* @__PURE__ */ c(() => be()[e]);
}
const oa = v(mt), sa = _t("available"), na = _t("accessGranted"), ra = _t("accessRequested");
function aa(e) {
  let t = !1, o, s;
  return e.available && (t = !0, o = e.access_requested, s = e.access_granted), {
    available: t,
    accessGranted: s || !1,
    accessRequested: o || !1
  };
}
const [
  ia,
  ca,
  ua,
  Xo
] = /* @__PURE__ */ pe(
  J,
  (e) => {
    const t = C() && S(J);
    return t ? f.resolve(t) : d("web_app_check_location", "location_checked", e).then(aa);
  },
  (e) => {
    be.set(e), M(J, e);
  }
), Zo = w(J, mt), la = I(J, Xo[0], mt), pa = Zo("mount", ia), [, da, ma] = ca, [, _a] = ua, [fa, ha] = Xo, [
  ba,
  ga,
  Ea
] = b(
  (e) => d("web_app_request_location", "location_requested", e).then((t) => {
    if (!t.available)
      throw be.set({ ...be(), available: !1 }), new ko("Location data tracking is not available");
    const { available: o, ...s } = t;
    return s;
  }),
  "Location request is currently in progress"
), Sa = la("requestLocation", ba), [, Jo, Ca] = ga, [, wa] = Ea, $a = Zo("openSettings", () => {
  i(io);
}, io);
function Ma() {
  Q(Jo), fa.set(!1);
}
const Yu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isAccessGranted: na,
  isAccessRequested: ra,
  isAvailable: sa,
  isMounted: ha,
  isMounting: ma,
  isRequestingLocation: Ca,
  isSupported: oa,
  mount: pa,
  mountError: _a,
  mountPromise: da,
  openSettings: $a,
  requestLocation: Sa,
  requestLocationError: wa,
  requestLocationPromise: Jo,
  unmount: Ma
}, Symbol.toStringTag, { value: "Module" }));
function ft(e) {
  const t = {};
  for (const o in e) {
    const s = e[o];
    s !== void 0 && (t[o] = s);
  }
  return t;
}
function es(e) {
  const t = Bn(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((o, s, n) => {
      const r = parseInt(t.slice(1 + n * 2, 1 + (n + 1) * 2), 16);
      return o + r * r * s;
    }, 0)
  ) < 120;
}
const [Fe, Aa] = /* @__PURE__ */ u(!1), [N, K] = /* @__PURE__ */ u({});
function h(e) {
  return /* @__PURE__ */ c(() => N()[e]);
}
const va = h("accent_text_color"), ts = h("bg_color"), ht = h("button_color"), os = h("button_text_color"), ya = h("bottom_bar_bg_color"), Ba = h("destructive_text_color"), Pa = h("header_bg_color"), Ta = h("hint_color"), ka = /* @__PURE__ */ c(() => {
  const e = ts();
  return !e || es(e);
}), Oa = h("link_color"), ss = h("secondary_bg_color"), Ia = h("section_bg_color"), Va = h("section_header_text_color"), qa = h("section_separator_color"), xa = h("subtitle_text_color"), Da = h("text_color");
function R(e) {
  return /* @__PURE__ */ c(() => bt()[e]);
}
const ee = /* @__PURE__ */ z({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  text: "Continue"
}), bt = /* @__PURE__ */ c(() => {
  const e = ee();
  return {
    ...e,
    backgroundColor: e.backgroundColor || ht() || "#2481cc",
    textColor: e.textColor || os() || "#ffffff"
  };
}), [Ye, ns] = /* @__PURE__ */ u(!1), Na = R("backgroundColor"), Ha = R("hasShineEffect"), La = R("isEnabled"), Ra = R("isLoaderVisible"), ja = R("isVisible"), Fa = R("text"), Ua = R("textColor"), Ga = "web_app_setup_main_button", rs = "main_button_pressed", Pe = "mainButton", gt = V(Pe), za = ye(Pe, ns), Wa = gt("mount", () => {
  if (!Ye()) {
    const e = C() && S(Pe);
    e && ee.set(e), Ye.set(!0);
  }
}), Qa = gt(
  "onClick",
  (e) => m(rs, e)
), Ka = gt(
  "offClick",
  (e) => {
    E(rs, e);
  }
), Ya = za(
  "setParams",
  (e) => {
    ee.set({ ...ee(), ...ft(e) }), M(Pe, ee());
    const t = bt();
    t.text && i(Ga, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function Xa() {
  Ye.set(!1);
}
const Xu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Na,
  hasShineEffect: Ha,
  isEnabled: La,
  isLoaderVisible: Ra,
  isMounted: ns,
  isVisible: ja,
  mount: Wa,
  offClick: Ka,
  onClick: Qa,
  setParams: Ya,
  state: bt,
  text: Fa,
  textColor: Ua,
  unmount: Xa
}, Symbol.toStringTag, { value: "Module" }));
function Et(e, t) {
  document.documentElement.style.setProperty(e, t);
}
function St(e) {
  document.documentElement.style.removeProperty(e);
}
const G = "themeParams", Ct = "theme_changed", as = V(G), wt = ({ theme_params: e }) => {
  N.set(e), M(G, e);
}, [
  Za,
  is,
  Ja,
  cs
] = /* @__PURE__ */ pe(
  G,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  (e) => f.resolve(
    C() && S(G) || le().tgWebAppThemeParams || {}
  ),
  (e) => {
    m(Ct, wt), N.set(e);
  }
), ei = ye(G, cs[0]), ti = ei(
  "bindCssVars",
  (e) => {
    if (Fe())
      throw new ot();
    e || (e = (s) => `--tg-theme-${gn(s)}`);
    function t(s) {
      Object.entries(N()).forEach(([n, r]) => {
        r && s(n, r);
      });
    }
    function o() {
      t((s, n) => {
        Et(e(s), n);
      });
    }
    return o(), N.sub(o), Fe.set(!0), () => {
      t(St), N.unsub(o), Fe.set(!1);
    };
  }
), us = as("mount", Za), oi = is[2], ls = is[1], si = Ja[1], [Xe, ni] = cs, ps = as("mountSync", () => {
  if (!Xe()) {
    const e = C() && S(G) || le().tgWebAppThemeParams || {};
    m(Ct, wt), se(() => {
      N.set(e), Xe.set(!0);
    });
  }
});
function ri() {
  Q(ls), E(Ct, wt), Xe.set(!1);
}
// @__NO_SIDE_EFFECTS__
function ds(e) {
  return /* @__PURE__ */ c(() => Te(e()));
}
function Te(e) {
  return Ce(e) ? e : K()[e];
}
const [ae, ai] = /* @__PURE__ */ u("bg_color"), $t = /* @__PURE__ */ ds(ae), [ie, ii] = /* @__PURE__ */ u("bottom_bar_bg_color"), Mt = /* @__PURE__ */ c(() => {
  const e = ie();
  return Ce(e) ? e : K()[e] || ss();
}), [ce, ci] = /* @__PURE__ */ u("bg_color"), ms = /* @__PURE__ */ ds(ce), [Ue, ui] = /* @__PURE__ */ u(!1), li = /* @__PURE__ */ c(() => {
  const e = $t();
  return e ? es(e) : !1;
}), [ke, pi] = /* @__PURE__ */ u(!0), _s = /* @__PURE__ */ c(() => ({
  backgroundColor: ae(),
  bottomBarColor: ie(),
  headerColor: ce(),
  isActive: ke()
})), Zu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accentTextColor: va,
  backgroundColor: ts,
  bindCssVars: ti,
  bottomBarBgColor: ya,
  buttonColor: ht,
  buttonTextColor: os,
  destructiveTextColor: Ba,
  headerBackgroundColor: Pa,
  hintColor: Ta,
  isCssVarsBound: Aa,
  isDark: ka,
  isMounted: ni,
  isMounting: oi,
  linkColor: Oa,
  mount: us,
  mountError: si,
  mountPromise: ls,
  mountSync: ps,
  secondaryBackgroundColor: ss,
  sectionBackgroundColor: Ia,
  sectionHeaderTextColor: Va,
  sectionSeparatorColor: qa,
  state: K,
  subtitleTextColor: xa,
  textColor: Da,
  unmount: ri
}, Symbol.toStringTag, { value: "Module" })), ge = "web_app_set_background_color", Ee = "web_app_set_bottom_bar_color", D = "web_app_set_header_color", At = "visibility_changed", H = "miniApp", vt = {
  any: [
    ge,
    Ee,
    D
  ]
}, di = /* @__PURE__ */ c(() => vt.any.some((e) => oe(e, O()))), yt = (e) => {
  ke.set(e.is_visible), Ie();
}, Bt = (e) => {
  [
    [ce, D],
    [ae, ge],
    [ie, Ee]
  ].forEach(([t, o]) => {
    const s = t();
    if (!Ce(s) && // Header color setter uses additional checks. We don't apply changes if the current
    // value is a known color key because it updates automatically by itself.
    (o !== D || s !== "bg_color" && s !== "secondary_bg_color")) {
      const n = e[s];
      n && i(o, { color: n });
    }
  });
}, [
  mi,
  fs,
  _i,
  hs
] = /* @__PURE__ */ pe(
  H,
  (e) => us(e).then(() => C() && S(H) || void 0),
  (e) => {
    Pt.ifAvailable(e ? e.backgroundColor : "bg_color"), Tt.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), kt.ifAvailable(e ? e.headerColor : "bg_color"), ke.set(e ? e.isActive : !0), m(At, yt), K.sub(Bt);
  }
), bs = V(H), gs = w(H, vt), Oe = I(H, hs[0], vt), fi = Oe(
  "bindCssVars",
  (e) => {
    if (Ue())
      throw new ot();
    const [t, o] = tt();
    function s(n, r) {
      function a() {
        Et(n, r() || null);
      }
      a(), t(r.sub(a), St.bind(null, n));
    }
    return e || (e = (n) => `--tg-${$o(n)}`), s(e("bgColor"), $t), s(e("bottomBarColor"), Mt), s(e("headerColor"), ms), t(() => {
      Ue.set(!1);
    }), Ue.set(!0), o;
  }
), hi = bs("close", (e) => {
  i("web_app_close", { return_back: e });
}), bi = gs("mount", mi), gi = fs[2], Es = fs[1], Ei = _i[1], [Ze, Si] = hs, Ci = gs("mountSync", () => {
  if (!Ze()) {
    ps();
    const e = C() && S(H) || void 0;
    Pt.ifAvailable(e ? e.backgroundColor : "bg_color"), Tt.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), kt.ifAvailable(e ? e.headerColor : "bg_color"), m(At, yt), K.sub(Bt), se(() => {
      ke.set(e ? e.isActive : !0), Ze.set(!0);
    });
  }
}), wi = bs("ready", () => {
  i("web_app_ready");
});
function Ie() {
  M(H, _s());
}
const Pt = Oe(
  "setBackgroundColor",
  (e) => {
    if (e === ae())
      return;
    const t = Te(e);
    if (!t)
      throw new st(e);
    i(ge, { color: t }), ae.set(e), Ie();
  },
  ge
), Tt = Oe(
  "setBottomBarColor",
  (e) => {
    if (e === ie())
      return;
    const t = Te(e);
    if (!t)
      throw new st(e);
    i(Ee, { color: t }), ie.set(e), Ie();
  },
  Ee
), kt = Oe(
  "setHeaderColor",
  (e) => {
    if (e !== ce()) {
      if (e === "bg_color" || e === "secondary_bg_color")
        i(D, { color_key: e });
      else {
        const t = Te(e);
        if (!t)
          throw new st(e);
        i(D, { color: t });
      }
      ce.set(e), Ie();
    }
  },
  D,
  {
    rgb: [D, "color", Ce]
  }
);
function $i() {
  Q(Es), E(At, yt), K.unsub(Bt), Ze.set(!1);
}
const Ju = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: ai,
  backgroundColorRGB: $t,
  bindCssVars: fi,
  bottomBarColor: ii,
  bottomBarColorRGB: Mt,
  close: hi,
  headerColor: ci,
  headerColorRGB: ms,
  isActive: pi,
  isCssVarsBound: ui,
  isDark: li,
  isMounted: Si,
  isMounting: gi,
  isSupported: di,
  mount: bi,
  mountError: Ei,
  mountPromise: Es,
  mountSync: Ci,
  ready: wi,
  setBackgroundColor: Pt,
  setBottomBarColor: Tt,
  setHeaderColor: kt,
  state: _s,
  unmount: $i
}, Symbol.toStringTag, { value: "Module" }));
function Mi(e) {
  const t = e.message.trim(), o = (e.title || "").trim(), s = e.buttons || [];
  if (o.length > 64)
    throw new y(`Invalid title: ${o}`);
  if (!t || t.length > 256)
    throw new y(`Invalid message: ${t}`);
  if (s.length > 3)
    throw new y(`Invalid buttons count: ${s.length}`);
  return {
    title: o,
    message: t,
    buttons: s.length ? s.map((n, r) => {
      const a = n.id || "";
      if (a.length > 64)
        throw new y(`Button with index ${r} has invalid id: ${a}`);
      if (!n.type || n.type === "default" || n.type === "destructive") {
        const l = n.text.trim();
        if (!l || l.length > 64)
          throw new y(`Button with index ${r} has invalid text: ${l}`);
        return { type: n.type, text: l, id: a };
      }
      return { type: n.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
const Ot = "web_app_open_popup", Ss = w("popup", Ot), Ai = v(Ot), [Cs, It, ws] = b(
  (e) => d(Ot, "popup_closed", {
    ...e,
    params: Mi(e)
  }).then(({ button_id: t }) => t === void 0 ? null : t),
  "A popup is already opened"
), vi = Ss("open", Cs), yi = It[1], Bi = It[2], Pi = ws[1], Ti = Ss("show", Cs), [, ki, Oi] = It, [, Ii] = ws, el = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: Bi,
  isShown: Oi,
  isSupported: Ai,
  open: vi,
  openError: Pi,
  openPromise: yi,
  show: Ti,
  showError: Ii,
  showPromise: ki
}, Symbol.toStringTag, { value: "Module" })), $s = "web_app_close_scan_qr_popup", Vt = "web_app_open_scan_qr_popup", Vi = "scan_qr_popup_closed", qi = "qr_text_received", Ms = w("qrScanner", Vt), xi = Ms("close", () => {
  i($s), Q(As);
}), Di = v(Vt);
function Ni(e) {
  e || (e = {});
  const { onCaptured: t, text: o, capture: s } = e, [, n] = tt(
    m(Vi, () => {
      r.resolve();
    }),
    m(qi, (a) => {
      t ? t(a.data) : (!s || s(a.data)) && (r.resolve(a.data), i($s));
    })
  ), r = new Cn(e);
  return (e.postEvent || i)(Vt, { text: o }), f.resolve(r).catch(qo).finally(n);
}
const [
  Hi,
  Li,
  Ri
] = b(Ni, "The QR Scanner is already opened"), ji = Ms("open", Hi), [, As, Fi] = Li, [, Ui] = Ri, tl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: xi,
  isOpened: Fi,
  isSupported: Di,
  open: ji,
  openError: Ui,
  openPromise: As
}, Symbol.toStringTag, { value: "Module" }));
function q(e) {
  return /* @__PURE__ */ c(() => qt()[e]);
}
const te = /* @__PURE__ */ z({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  position: "left",
  text: "Cancel"
}), qt = /* @__PURE__ */ c(() => {
  const e = te();
  return {
    ...e,
    backgroundColor: e.backgroundColor || Mt() || "#000000",
    textColor: e.textColor || ht() || "#2481cc"
  };
}), [Je, vs] = /* @__PURE__ */ u(!1), Gi = q("backgroundColor"), zi = q("hasShineEffect"), Wi = q("isEnabled"), Qi = q("isLoaderVisible"), Ki = q("isVisible"), Yi = q("position"), Xi = q("text"), Zi = q("textColor"), Ve = "web_app_setup_secondary_button", ys = "secondary_button_pressed", qe = "secondaryButton", xt = w(qe, Ve), Ji = I(qe, vs, Ve), ec = v(Ve), tc = xt("mount", () => {
  if (!Je()) {
    const e = C() && S(qe);
    e && te.set(e), Je.set(!0);
  }
}), oc = xt(
  "onClick",
  (e) => m(ys, e)
), sc = xt(
  "offClick",
  (e) => {
    E(ys, e);
  }
), nc = Ji(
  "setParams",
  (e) => {
    te.set({ ...te(), ...ft(e) }), M(qe, te());
    const t = qt();
    t.text && i(Ve, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      position: t.position,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function rc() {
  Je.set(!1);
}
const ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Gi,
  hasShineEffect: zi,
  isEnabled: Wi,
  isLoaderVisible: Qi,
  isMounted: vs,
  isSupported: ec,
  isVisible: Ki,
  mount: tc,
  offClick: sc,
  onClick: oc,
  position: Yi,
  setParams: nc,
  state: qt,
  text: Xi,
  textColor: Zi,
  unmount: rc
}, Symbol.toStringTag, { value: "Module" })), xe = "web_app_setup_settings_button", Bs = "settings_button_pressed", De = "settingsButton", [co, ac] = /* @__PURE__ */ u(!1), [Se, ic] = /* @__PURE__ */ u(!1), cc = v(xe), Dt = w(De, xe), Ps = I(De, Se, xe), uc = Ps("hide", () => {
  Nt(!1);
}), lc = Dt("mount", () => {
  Se() || (Nt(C() && S(De) || !1), Se.set(!0));
});
function Nt(e) {
  e !== co() && (i(xe, { is_visible: e }), M(De, e), co.set(e));
}
const pc = Dt(
  "onClick",
  (e) => m(Bs, e)
), dc = Dt(
  "offClick",
  (e) => {
    E(Bs, e);
  }
), mc = Ps("show", () => {
  Nt(!0);
});
function _c() {
  Se.set(!1);
}
const sl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: uc,
  isMounted: ic,
  isSupported: cc,
  isVisible: ac,
  mount: lc,
  offClick: dc,
  onClick: pc,
  show: mc,
  unmount: _c
}, Symbol.toStringTag, { value: "Module" })), Ne = "web_app_setup_swipe_behavior", He = "swipeBehavior", [ue, fc] = /* @__PURE__ */ u(!1), hc = v(Ne), [et, bc] = /* @__PURE__ */ u(!0), gc = w(He, Ne), Ts = I(He, ue, Ne), Ec = Ts("disableVertical", () => {
  Ht(!1);
}), Sc = Ts("enableVertical", () => {
  Ht(!0);
}), Cc = gc("mount", () => {
  ue() || (Ht(
    C() && S(He) || !1,
    !0
  ), ue.set(!0));
});
function Ht(e, t) {
  (e !== et() || t) && (i(Ne, { allow_vertical_swipe: e }), M(He, e), et.set(e));
}
function wc() {
  ue.set(!1);
}
const nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _isMounted: ue,
  _isVerticalEnabled: et,
  disableVertical: Ec,
  enableVertical: Sc,
  isMounted: fc,
  isSupported: hc,
  isVerticalEnabled: bc,
  mount: Cc,
  unmount: wc
}, Symbol.toStringTag, { value: "Module" })), j = "viewport", Lt = "fullscreen_changed", Rt = "safe_area_changed", jt = "content_safe_area_changed", Ft = "viewport_changed", ks = V(j), uo = { left: 0, top: 0, bottom: 0, right: 0 };
function Ge(e) {
  return Math.max(e, 0);
}
const [ze, Os] = /* @__PURE__ */ u({
  contentSafeAreaInsets: uo,
  height: 0,
  isExpanded: !1,
  isFullscreen: !1,
  safeAreaInsets: uo,
  stableHeight: 0,
  width: 0
});
function F(e) {
  return /* @__PURE__ */ c(() => Os()[e]);
}
const Ut = F("height"), Gt = F("stableHeight"), Is = F("width"), $c = F("isExpanded"), Mc = /* @__PURE__ */ c(() => Ut() === Gt());
function Y(e) {
  const { height: t, stableHeight: o, width: s } = e;
  ze.set({
    ...ze(),
    ...ft({
      ...e,
      height: t ? Ge(t) : void 0,
      width: s ? Ge(s) : void 0,
      stableHeight: o ? Ge(o) : void 0
    })
  }), M(j, ze());
}
function Ac() {
  return S(j);
}
function Le(e) {
  return /* @__PURE__ */ c(() => zt()[e]);
}
const zt = F("contentSafeAreaInsets"), Vs = Le("bottom"), qs = Le("left"), xs = Le("right"), Ds = Le("top");
function Re(e) {
  return /* @__PURE__ */ c(() => Wt()[e]);
}
const Wt = F("safeAreaInsets"), Ns = Re("bottom"), Hs = Re("left"), Ls = Re("right"), Rs = Re("top"), js = "web_app_request_safe_area", Fs = w(j, js), lo = Fs(
  "requestContentSafeAreaInsets",
  (e) => d("web_app_request_content_safe_area", jt, e)
);
function vc(e) {
  return d("web_app_request_viewport", Ft, e);
}
const po = Fs(
  "requestSafeAreaInsets",
  (e) => d(js, Rt, e)
), Us = (e) => {
  const { height: t } = e;
  Y({
    isExpanded: e.is_expanded,
    height: t,
    width: e.width,
    stableHeight: e.is_state_stable ? t : void 0
  });
}, Gs = (e) => {
  Y({ isFullscreen: e.is_fullscreen });
}, zs = (e) => {
  Y({ safeAreaInsets: e });
}, Ws = (e) => {
  Y({ contentSafeAreaInsets: e });
}, [
  yc,
  Bc,
  Pc,
  Tc
] = /* @__PURE__ */ pe(
  j,
  (e) => {
    const t = C() && Ac();
    return t ? f.resolve(t) : f.fn(async (o) => {
      const s = await f.all([
        po.isAvailable() ? po(o) : Wt(),
        lo.isAvailable() ? lo(o) : zt()
      ]), n = le(), r = {
        contentSafeAreaInsets: s[1],
        isFullscreen: !!n.tgWebAppFullscreen,
        safeAreaInsets: s[0]
      };
      if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(n.tgWebAppPlatform)) {
        const a = window;
        return {
          ...r,
          height: a.innerHeight,
          isExpanded: !0,
          stableHeight: a.innerHeight,
          width: a.innerWidth
        };
      }
      return vc(o).then((a) => ({
        ...r,
        height: a.height,
        isExpanded: a.is_expanded,
        stableHeight: a.is_state_stable ? a.height : 0,
        width: a.width
      }));
    }, e);
  },
  (e) => {
    m(Ft, Us), m(Lt, Gs), m(Rt, zs), m(jt, Ws), Y(e);
  }
), kc = ks("mount", yc), [, Qs, Oc] = Bc, [, Ic] = Pc, [Qt, Vc] = Tc;
function qc() {
  Q(Qs), E(Ft, Us), E(Lt, Gs), E(Rt, zs), E(jt, Ws), Qt.set(!1);
}
const xc = ye(j, Qt), [We, Dc] = /* @__PURE__ */ u(!1), Nc = xc(
  "bindCssVars",
  (e) => {
    if (We())
      throw new ot();
    e || (e = (o) => `--tg-viewport-${$o(o)}`);
    const t = [
      ["height", Ut],
      ["stableHeight", Gt],
      ["width", Is],
      ["safeAreaInsetTop", Rs],
      ["safeAreaInsetBottom", Ns],
      ["safeAreaInsetLeft", Hs],
      ["safeAreaInsetRight", Ls],
      ["contentSafeAreaInsetTop", Ds],
      ["contentSafeAreaInsetBottom", Vs],
      ["contentSafeAreaInsetLeft", qs],
      ["contentSafeAreaInsetRight", xs]
    ].reduce((o, [s, n]) => {
      const r = e(s);
      if (r) {
        const a = () => {
          Et(r, `${n()}px`);
        };
        o.push([a, n.sub(a), r]);
      }
      return o;
    }, []);
    return t.forEach((o) => {
      o[0]();
    }), We.set(!0), () => {
      t.forEach((o) => {
        o[1](), St(o[2]);
      }), We.set(!1);
    };
  }
), Hc = ks("expand", () => {
  i("web_app_expand");
}), Ks = "web_app_request_fullscreen", Lc = I(j, Qt, Ks), Ys = F("isFullscreen"), [
  Rc,
  jc
] = /* @__PURE__ */ u(), [
  Fc,
  Uc
] = /* @__PURE__ */ u();
function Xs(e, t) {
  return Lc(
    e,
    b(
      (o) => d(
        t ? Ks : "web_app_exit_fullscreen",
        [Lt, "fullscreen_failed"],
        o
      ).then((s) => {
        if ("error" in s && s.error !== "ALREADY_FULLSCREEN")
          throw new Vn(s.error);
        const n = "is_fullscreen" in s ? s.is_fullscreen : !0;
        n !== Ys() && Y({ isFullscreen: n });
      }),
      "Fullscreen mode change is already being requested",
      {
        promise: Rc,
        error: Fc
      }
    )[0]
  );
}
const Gc = Xs("requestFullscreen", !0), zc = Xs("exitFullscreen"), rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCssVars: Nc,
  changeFullscreenError: Uc,
  changeFullscreenPromise: jc,
  contentSafeAreaInsetBottom: Vs,
  contentSafeAreaInsetLeft: qs,
  contentSafeAreaInsetRight: xs,
  contentSafeAreaInsetTop: Ds,
  contentSafeAreaInsets: zt,
  exitFullscreen: zc,
  expand: Hc,
  height: Ut,
  isCssVarsBound: Dc,
  isExpanded: $c,
  isFullscreen: Ys,
  isMounted: Vc,
  isMounting: Oc,
  isStable: Mc,
  mount: kc,
  mountError: Ic,
  mountPromise: Qs,
  requestFullscreen: Gc,
  safeAreaInsetBottom: Ns,
  safeAreaInsetLeft: Hs,
  safeAreaInsetRight: Ls,
  safeAreaInsetTop: Rs,
  safeAreaInsets: Wt,
  stableHeight: Gt,
  state: Os,
  unmount: qc,
  width: Is
}, Symbol.toStringTag, { value: "Module" })), Zs = "web_app_request_emoji_status_access", [
  Wc,
  Qc,
  Kc
] = b((e) => d(Zs, "emoji_status_access_requested", e).then((t) => t.status), "Emoji status access request is already in progress"), al = /* @__PURE__ */ p(
  "requestEmojiStatusAccess",
  Wc,
  { isSupported: Zs }
), [, il, cl] = Qc, [, ul] = Kc, Js = "web_app_set_emoji_status", [
  Yc,
  Xc,
  Zc
] = b(
  (e, t) => d(Js, ["emoji_status_set", "emoji_status_failed"], {
    params: {
      custom_emoji_id: e,
      duration: (t || {}).duration
    },
    ...t
  }).then((o) => {
    if (o && "error" in o)
      throw new In(o.error);
  }),
  "Emoji status set request is currently in progress"
), ll = /* @__PURE__ */ p("setEmojiStatus", Yc, {
  isSupported: Js
}), [, pl, dl] = Xc, [, ml] = Zc, Jc = { isSupported: "web_app_add_to_home_screen" }, en = "home_screen_failed", _l = /* @__PURE__ */ p(
  "onAddToHomeScreenFailed",
  (e, t) => m(en, e, t),
  { isSupported: "web_app_add_to_home_screen" }
), fl = /* @__PURE__ */ p(
  "offAddToHomeScreenFailed",
  (e) => {
    E(en, e);
  },
  Jc
), tn = { isSupported: "web_app_add_to_home_screen" }, on = "home_screen_added", hl = /* @__PURE__ */ p(
  "onAddedToHomeScreen",
  (e, t) => m(on, e, t),
  tn
), bl = /* @__PURE__ */ p(
  "offAddedToHomeScreen",
  (e) => {
    E(on, e);
  },
  tn
), mo = "web_app_add_to_home_screen", gl = /* @__PURE__ */ p(
  "addToHomeScreen",
  () => {
    i(mo);
  },
  { isSupported: mo }
), sn = "web_app_check_home_screen", [
  eu,
  tu,
  ou
] = b((e) => d(sn, "home_screen_checked", e).then((t) => t.status || "unknown"), "Check home screen status request is currently in progress"), El = /* @__PURE__ */ p("checkHomeScreenStatus", eu, {
  isSupported: sn
}), [, Sl, Cl] = tu, [, wl] = ou, su = V(), $l = su(
  "openLink",
  (e, t) => {
    if (typeof e == "string")
      try {
        e = new URL(e);
      } catch (o) {
        throw new y(`"${e.toString()}" is invalid URL`, o);
      }
    t || (t = {}), i("web_app_open_link", {
      url: e.toString(),
      try_browser: t.tryBrowser,
      try_instant_view: t.tryInstantView
    });
  }
), _o = "web_app_open_tg_link", nu = V(), ru = nu(
  "openTelegramLink",
  (e) => {
    const t = e.toString();
    if (!t.match(/^https:\/\/t.me\/.+/))
      throw new y(`"${t}" is invalid URL`);
    if (!oe(_o, O())) {
      window.location.href = t;
      return;
    }
    e = new URL(e), i(_o, { path_full: e.pathname + e.search });
  }
), au = V(), Ml = au(
  "shareURL",
  (e, t) => {
    ru(
      "https://t.me/share/url?" + new URLSearchParams({ url: e, text: t || "" }).toString().replace(/\+/g, "%20")
    );
  }
);
function iu(e, t) {
  return new f({ abortSignal: t, timeout: e }).catch(() => {
  });
}
const nn = "web_app_request_phone", [
  cu,
  uu,
  lu
] = b((e) => d(nn, "phone_requested", e).then((t) => t.status), "Phone access request is currently in progress"), pu = /* @__PURE__ */ p("requestPhoneAccess", cu, {
  isSupported: nn
}), [, Al, vl] = uu, [, yl] = lu, rn = {
  isSupported: "web_app_request_phone"
};
async function fo(e) {
  const t = ne($(), await W("getRequestedContact", {}, {
    ...e,
    timeout: (e || {}).timeout || 5e3
  }));
  return {
    raw: t,
    parsed: ne(
      fe(
        // todo: Union is unnecessary here, but we use it to comply TypeScript checker.
        Mn([$(), An(URLSearchParams)]),
        Pn(
          to({
            contact: fe(
              $(),
              Tn(),
              to({
                user_id: yo(),
                phone_number: $(),
                first_name: $(),
                last_name: vn($())
              })
            ),
            auth_date: fe(
              $(),
              Ao((o) => new Date(Number(o) * 1e3)),
              vo()
            ),
            hash: $()
          })
        )
      ),
      t
    )
  };
}
const [du, mu, _u] = b(
  (e) => new f(
    async (t, o, s) => {
      try {
        return t(await fo(s));
      } catch (a) {
        if (a instanceof eo)
          throw a;
      }
      if (await pu(s) !== "sent")
        throw new Oo("User denied access");
      let r = 50;
      for (; !s.isAborted(); ) {
        try {
          return t(await fo(s));
        } catch (a) {
          if (a instanceof eo)
            throw a;
        }
        await iu(r), r += 50;
      }
    },
    e
  ),
  "Contact is already being requested"
), fu = /* @__PURE__ */ p("requestContactComplete", du, rn), Bl = /* @__PURE__ */ p(
  "requestContact",
  (e) => fu(e).then((t) => t.parsed),
  rn
), [, Pl, Tl] = mu, [, kl] = _u, an = "web_app_request_write_access", [
  hu,
  bu,
  gu
] = b(
  (e) => d(an, "write_access_requested", e).then((t) => t.status),
  "Write access request is currently in progress"
), Ol = /* @__PURE__ */ p("requestWriteAccess", hu, {
  isSupported: an
}), [, Il, Vl] = bu, [, ql] = gu;
function Eu(e) {
  const t = document.createElement("textarea");
  t.value = e, t.style.top = "0", t.style.left = "0", t.style.position = "fixed", document.body.appendChild(t), t.focus(), t.select();
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(t);
  }
}
async function xl(e) {
  try {
    const { clipboard: t } = navigator;
    if (t)
      return await t.writeText(e);
  } catch {
  }
  Eu(e);
}
const ho = "web_app_request_file_download", Dl = /* @__PURE__ */ p(
  "downloadFile",
  (e, t, o) => d(
    ho,
    "file_download_requested",
    { ...o, params: { url: e, file_name: t } }
  ).then((s) => {
    if (s.status !== "downloading")
      throw new Oo("User denied the action");
  }),
  { isSupported: ho }
), Nl = /* @__PURE__ */ p(
  "getCurrentTime",
  (e) => W("getCurrentTime", {}, e).then((t) => ne(
    fe(yo(), yn(), Ao((o) => new Date(o * 1e3)), vo()),
    t
  )),
  { isSupported: "web_app_invoke_custom_method" }
), bo = "web_app_hide_keyboard", Hl = /* @__PURE__ */ p(
  "hideKeyboard",
  () => i(bo),
  { isSupported: bo }
), go = "web_app_read_text_from_clipboard", Ll = /* @__PURE__ */ p(
  "readTextFromClipboard",
  (e) => {
    const t = To();
    return d(go, "clipboard_text_received", {
      ...e,
      params: { req_id: t },
      capture: hn(t)
    }).then(({ data: o = null }) => o);
  },
  { isSupported: go }
);
function Su(e) {
  const t = {}, o = e.match(/Telegram-Android(?:\/([^ ]+))?(?: (\([^)]+\))?|$)/);
  if (o) {
    const [, s, n] = o;
    s && (t.appVersion = s), n && n.slice(1, n.length - 1).split(";").forEach((r) => {
      const [a, l] = r.trim().split(" ");
      if (a === "Android")
        t.androidVersion = l;
      else if (a === "SDK") {
        const P = parseInt(l, 10);
        P && (t.sdkVersion = P);
      } else l ? (t.manufacturer = a, t.model = l) : t.performanceClass = a;
    });
  }
  return t;
}
function Rl() {
  return Su(navigator.userAgent);
}
const Eo = "web_app_data_send", jl = /* @__PURE__ */ p(
  "sendData",
  (e) => {
    const { size: t } = new Blob([e]);
    if (!t || t > 4096)
      throw new y(t ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    i(Eo, { data: e });
  },
  { isSupported: Eo }
), So = "web_app_send_prepared_message", Fl = /* @__PURE__ */ p(
  "shareMessage",
  (e, t) => d(So, ["prepared_message_failed", "prepared_message_sent"], {
    ...t,
    params: { id: e }
  }).then((o) => {
    if (o && "error" in o)
      throw new qn(o.error);
  }),
  { isSupported: So }
), Co = "web_app_share_to_story", Ul = /* @__PURE__ */ p(
  "shareStory",
  (e, t) => {
    t || (t = {}), i(Co, {
      text: t.text,
      media_url: e,
      widget_link: t.widgetLink
    });
  },
  { isSupported: Co }
), Cu = "web_app_switch_inline_query", Gl = /* @__PURE__ */ p(
  "switchInlineQuery",
  (e, t) => {
    i(Cu, {
      query: e,
      chat_types: t || []
    });
  },
  {
    isSupported() {
      return le().tgWebAppBotInline ? void 0 : "The application must be launched in the inline mode";
    }
  }
);
function zl(e) {
  try {
    return [!0, e()];
  } catch (t) {
    return [!1, t];
  }
}
function Wl(e) {
  kn(e);
  const [t, o] = tt(
    m("reload_iframe", () => {
      Qe().log("Received a request to reload the page"), i("iframe_will_reload"), window.location.reload();
    })
  ), { acceptCustomStyles: s = !0 } = e || {};
  if (s) {
    const n = document.createElement("style");
    n.id = "telegram-custom-styles", document.head.appendChild(n), t(
      m("set_custom_style", (r) => {
        n.innerHTML = r;
      }),
      () => {
        document.head.removeChild(n);
      }
    );
  }
  return i("iframe_ready", { reload_supported: !0 }), Qe().log("The package was initialized"), o;
}
export {
  Yl as AbortablePromise,
  Oo as AccessDeniedError,
  ot as CSSVarsBoundError,
  Xl as CancelledError,
  On as ConcurrentCallError,
  Vn as FullscreenFailedError,
  Z as FunctionUnavailableError,
  y as InvalidArgumentsError,
  Iu as InvalidEnvError,
  Zl as InvalidLaunchParamsError,
  Jl as InvokeCustomMethodError,
  ep as LaunchParamsRetrieveError,
  tp as ManualPromise,
  op as MethodParameterUnsupportedError,
  sp as MethodUnsupportedError,
  ko as NotAvailableError,
  In as SetEmojiStatusError,
  qn as ShareMessageError,
  np as TimeoutError,
  rp as UnknownEnvError,
  st as UnknownThemeParamsKeyError,
  gl as addToHomeScreen,
  ap as applyPolyfills,
  ar as authenticateBiometry,
  Fu as backButton,
  fi as bindMiniAppCssVars,
  ti as bindThemeParamsCssVars,
  Nc as bindViewportCssVars,
  Uu as biometry,
  cr as biometryAuthError,
  Ro as biometryAuthPromise,
  er as biometryMountError,
  Gn as biometryState,
  ip as bridgeLogger,
  Uc as changeFullscreenError,
  jc as changeFullscreenPromise,
  El as checkHomeScreenStatus,
  wl as checkHomeScreenStatusError,
  Sl as checkHomeScreenStatusPromise,
  hi as closeMiniApp,
  xi as closeQrScanner,
  Gu as closingBehavior,
  zu as cloudStorage,
  kn as configure,
  xl as copyTextToClipboard,
  qp as createLogger,
  cp as createPostEvent,
  To as createRequestId,
  up as createStartParam,
  lp as decodeBase64Url,
  pp as decodeStartParam,
  zo as deleteCloudStorageItem,
  Sr as disableClosingConfirmation,
  Ec as disableVerticalSwipes,
  Dl as downloadFile,
  dp as emitEvent,
  Cr as enableClosingConfirmation,
  Sc as enableVerticalSwipes,
  mp as encodeBase64Url,
  zc as exitFullscreen,
  Hc as expandViewport,
  vr as getCloudStorageItem,
  Wo as getCloudStorageKeys,
  Nl as getCurrentTime,
  Wu as hapticFeedback,
  Tr as hapticFeedbackImpactOccurred,
  kr as hapticFeedbackNotificationOccurred,
  Or as hapticFeedbackSelectionChanged,
  Hn as hideBackButton,
  Hl as hideKeyboard,
  uc as hideSettingsButton,
  qo as ignoreCanceled,
  Wl as init,
  Qu as initData,
  Ko as initDataAuthDate,
  Yo as initDataCanSendAfter,
  Vr as initDataCanSendAfterDate,
  qr as initDataChat,
  Dr as initDataChatInstance,
  xr as initDataChatType,
  Nr as initDataHash,
  Hr as initDataQueryId,
  Rr as initDataRaw,
  jr as initDataReceiver,
  Ur as initDataStartParam,
  Ir as initDataState,
  Gr as initDataUser,
  Ku as invoice,
  W as invokeCustomMethod,
  Hu as isAccessDeniedError,
  ir as isAuthenticatingBiometry,
  Dn as isBackButtonMounted,
  Nn as isBackButtonSupported,
  xn as isBackButtonVisible,
  zn as isBiometryAvailable,
  or as isBiometryMounted,
  Jn as isBiometryMounting,
  Qn as isBiometrySupported,
  ku as isCSSVarsBoundError,
  _p as isCancelledError,
  Cl as isCheckingHomeScreenStatus,
  Fo as isClosingBehaviorMounted,
  gr as isClosingConfirmationEnabled,
  Mr as isCloudStorageSupported,
  es as isColorDark,
  Du as isConcurrentCallError,
  Ys as isFullscreen,
  Lu as isFullscreenFailedError,
  qu as isFunctionNotAvailableError,
  Pr as isHapticFeedbackSupported,
  xu as isInvalidArguments,
  Vu as isInvalidEnvError,
  fp as isInvalidLaunchParamsError,
  ea as isInvoiceOpened,
  Wr as isInvoiceSupported,
  hp as isInvokeCustomMethodError,
  bp as isLaunchParamsRetrieveError,
  na as isLocationManagerAccessGranted,
  ra as isLocationManagerAccessRequested,
  sa as isLocationManagerAvailable,
  ha as isLocationManagerMounted,
  ma as isLocationManagerMounting,
  oa as isLocationManagerSupported,
  La as isMainButtonEnabled,
  Ra as isMainButtonLoaderVisible,
  ns as isMainButtonMounted,
  ja as isMainButtonVisible,
  gp as isMethodMethodParameterUnsupportedError,
  Ep as isMethodUnsupportedError,
  pi as isMiniAppActive,
  ui as isMiniAppCssVarsBound,
  li as isMiniAppDark,
  Si as isMiniAppMounted,
  gi as isMiniAppMounting,
  di as isMiniAppSupported,
  Ou as isNotAvailableError,
  Bi as isPopupOpened,
  Oi as isPopupShown,
  Ai as isPopupSupported,
  Fi as isQrScannerOpened,
  Di as isQrScannerSupported,
  Dp as isRGB,
  Np as isRGBShort,
  _r as isRequestingBiometryAccess,
  Tl as isRequestingContact,
  cl as isRequestingEmojiStatusAccess,
  Ca as isRequestingLocation,
  vl as isRequestingPhoneAccess,
  Vl as isRequestingWriteAccess,
  so as isSSR,
  Sp as isSafeToCreateStartParam,
  Wi as isSecondaryButtonEnabled,
  Qi as isSecondaryButtonLoaderVisible,
  vs as isSecondaryButtonMounted,
  ec as isSecondaryButtonSupported,
  Ki as isSecondaryButtonVisible,
  Nu as isSetEmojiStatusError,
  dl as isSettingEmojiStatus,
  ic as isSettingsButtonMounted,
  cc as isSettingsButtonSupported,
  ac as isSettingsButtonVisible,
  Ru as isShareMessageError,
  fc as isSwipeBehaviorMounted,
  hc as isSwipeBehaviorSupported,
  Cp as isTMA,
  Aa as isThemeParamsCssVarsBound,
  ka as isThemeParamsDark,
  ni as isThemeParamsMounted,
  oi as isThemeParamsMounting,
  wp as isTimeoutError,
  $p as isUnknownEnvError,
  ju as isUnknownThemeParamsKeyError,
  bc as isVerticalSwipesEnabled,
  Dc as isViewportCssVarsBound,
  $c as isViewportExpanded,
  Vc as isViewportMounted,
  Oc as isViewportMounting,
  Mc as isViewportStable,
  Yu as locationManager,
  _a as locationManagerMountError,
  da as locationManagerMountPromise,
  Xu as mainButton,
  Na as mainButtonBackgroundColor,
  Ha as mainButtonHasShineEffect,
  bt as mainButtonState,
  Fa as mainButtonText,
  Ua as mainButtonTextColor,
  Ju as miniApp,
  ai as miniAppBackgroundColor,
  $t as miniAppBackgroundColorRGB,
  ii as miniAppBottomBarColor,
  Mt as miniAppBottomBarColorRGB,
  ci as miniAppHeaderColor,
  ms as miniAppHeaderColorRGB,
  Ei as miniAppMountError,
  Es as miniAppMountPromise,
  wi as miniAppReady,
  _s as miniAppState,
  Mp as mockTelegramEnv,
  Ln as mountBackButton,
  Zn as mountBiometry,
  Lo as mountBiometryPromise,
  wr as mountClosingBehavior,
  pa as mountLocationManager,
  Wa as mountMainButton,
  bi as mountMiniApp,
  Ci as mountMiniAppSync,
  tc as mountSecondaryButton,
  lc as mountSettingsButton,
  Cc as mountSwipeBehavior,
  us as mountThemeParams,
  ps as mountThemeParamsSync,
  kc as mountViewport,
  Ap as off,
  fl as offAddToHomeScreenFailed,
  bl as offAddedToHomeScreen,
  jn as offBackButtonClick,
  Ka as offMainButtonClick,
  sc as offSecondaryButtonClick,
  dc as offSettingsButtonClick,
  vp as on,
  _l as onAddToHomeScreenFailed,
  hl as onAddedToHomeScreen,
  Rn as onBackButtonClick,
  Qa as onMainButtonClick,
  oc as onSecondaryButtonClick,
  pc as onSettingsButtonClick,
  ur as openBiometrySettings,
  Zr as openInvoice,
  ta as openInvoiceError,
  Jr as openInvoicePromise,
  $l as openLink,
  $a as openLocationManagerSettings,
  vi as openPopup,
  Pi as openPopupError,
  yi as openPopupPromise,
  ji as openQrScanner,
  Ui as openQrScannerError,
  As as openQrScannerPromise,
  ru as openTelegramLink,
  Hp as parseInitDataQuery,
  Lp as parseLaunchParamsQuery,
  el as popup,
  i as postEvent,
  yp as postMessage,
  Bp as postMessageImplementation,
  tl as qrScanner,
  Ll as readTextFromClipboard,
  d as request,
  Wn as requestBiometry,
  mr as requestBiometryAccess,
  fr as requestBiometryAccessError,
  jo as requestBiometryAccessPromise,
  Bl as requestContact,
  fu as requestContactComplete,
  kl as requestContactError,
  Pl as requestContactPromise,
  lo as requestContentSafeAreaInsets,
  al as requestEmojiStatusAccess,
  ul as requestEmojiStatusAccessError,
  il as requestEmojiStatusAccessPromise,
  Gc as requestFullscreen,
  Sa as requestLocation,
  wa as requestLocationError,
  Jo as requestLocationPromise,
  pu as requestPhoneAccess,
  yl as requestPhoneAccessError,
  Al as requestPhoneAccessPromise,
  po as requestSafeAreaInsets,
  vc as requestViewport,
  Ol as requestWriteAccess,
  ql as requestWriteAccessError,
  Il as requestWriteAccessPromise,
  Fr as restoreInitData,
  Rl as retrieveAndroidDeviceData,
  Su as retrieveAndroidDeviceDataFrom,
  Pp as retrieveLaunchParams,
  Tp as retrieveRawInitData,
  kp as retrieveRawLaunchParams,
  zl as safeCall,
  Qe as sdkLogger,
  ol as secondaryButton,
  Gi as secondaryButtonBackgroundColor,
  zi as secondaryButtonHasShineEffect,
  Yi as secondaryButtonPosition,
  qt as secondaryButtonState,
  Xi as secondaryButtonText,
  Zi as secondaryButtonTextColor,
  jl as sendData,
  Rp as serializeInitDataQuery,
  jp as serializeLaunchParamsQuery,
  Fp as serializeToQuery,
  yr as setCloudStorageItem,
  Tu as setDebug,
  ll as setEmojiStatus,
  ml as setEmojiStatusError,
  pl as setEmojiStatusPromise,
  Ya as setMainButtonParams,
  Pt as setMiniAppBackgroundColor,
  Tt as setMiniAppBottomBarColor,
  kt as setMiniAppHeaderColor,
  nc as setSecondaryButtonParams,
  sl as settingsButton,
  Fl as shareMessage,
  Ul as shareStory,
  Ml as shareURL,
  Fn as showBackButton,
  Ti as showPopup,
  Ii as showPopupError,
  ki as showPopupPromise,
  mc as showSettingsButton,
  Op as supports,
  nl as swipeBehavior,
  Gl as switchInlineQuery,
  Ip as targetOrigin,
  Zu as themeParams,
  va as themeParamsAccentTextColor,
  ts as themeParamsBackgroundColor,
  ya as themeParamsBottomBarBgColor,
  ht as themeParamsButtonColor,
  os as themeParamsButtonTextColor,
  Ba as themeParamsDestructiveTextColor,
  Pa as themeParamsHeaderBackgroundColor,
  Ta as themeParamsHintColor,
  Oa as themeParamsLinkColor,
  si as themeParamsMountError,
  ls as themeParamsMountPromise,
  ss as themeParamsSecondaryBackgroundColor,
  Ia as themeParamsSectionBackgroundColor,
  Va as themeParamsSectionHeaderTextColor,
  qa as themeParamsSectionSeparatorColor,
  K as themeParamsState,
  xa as themeParamsSubtitleTextColor,
  Da as themeParamsTextColor,
  Up as toRGB,
  Gp as transformQueryUsing,
  Un as unmountBackButton,
  hr as unmountBiometry,
  $r as unmountClosingBehavior,
  Ma as unmountLocationManager,
  Xa as unmountMainButton,
  $i as unmountMiniApp,
  rc as unmountSecondaryButton,
  _c as unmountSettingsButton,
  wc as unmountSwipeBehavior,
  ri as unmountThemeParams,
  qc as unmountViewport,
  br as updateBiometryToken,
  rl as viewport,
  Vs as viewportContentSafeAreaInsetBottom,
  qs as viewportContentSafeAreaInsetLeft,
  xs as viewportContentSafeAreaInsetRight,
  Ds as viewportContentSafeAreaInsetTop,
  zt as viewportContentSafeAreaInsets,
  Ut as viewportHeight,
  Ic as viewportMountError,
  Qs as viewportMountPromise,
  Ns as viewportSafeAreaInsetBottom,
  Hs as viewportSafeAreaInsetLeft,
  Ls as viewportSafeAreaInsetRight,
  Rs as viewportSafeAreaInsetTop,
  Wt as viewportSafeAreaInsets,
  Gt as viewportStableHeight,
  Os as viewportState,
  Is as viewportWidth,
  p as wrapSafe
};
//# sourceMappingURL=index.js.map
