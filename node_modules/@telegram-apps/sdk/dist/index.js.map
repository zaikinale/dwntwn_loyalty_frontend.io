{"version":3,"file":"index.js","sources":["../src/signals-registry.ts","../src/debug.ts","../src/logger.ts","../src/globals.ts","../src/scopes/createIsSupported.ts","../src/errors.ts","../src/utils/isSSR.ts","../src/scopes/wrappers/wrapSafe.ts","../src/scopes/wrappers/createWrapSafe.ts","../src/scopes/wrappers/createWrapComplete.ts","../src/scopes/wrappers/createWrapSupported.ts","../src/scopes/components/back-button/back-button.ts","../src/scopes/defineNonConcurrentFn.ts","../src/scopes/defineMountFn.ts","../src/scopes/components/biometry/signals.ts","../src/scopes/components/biometry/requestBiometry.ts","../src/utils/ignoreCanceled.ts","../src/scopes/signalCancel.ts","../src/scopes/components/biometry/methods.ts","../src/scopes/wrappers/createWrapMounted.ts","../src/scopes/wrappers/createWrapBasic.ts","../src/scopes/components/closing-behavior/closing-behavior.ts","../src/scopes/components/cloud-storage/cloud-storage.ts","../src/scopes/components/haptic-feedback/haptic-feedback.ts","../src/scopes/components/init-data/init-data.ts","../src/scopes/components/invoice/invoice.ts","../src/scopes/components/location-manager/location-manager.ts","../src/utils/removeUndefined.ts","../src/utils/isColorDark.ts","../src/scopes/components/theme-params/signals.ts","../src/scopes/components/main-button/signals.ts","../src/scopes/components/main-button/methods.ts","../src/utils/css-vars.ts","../src/scopes/components/theme-params/methods.ts","../src/scopes/components/mini-app/utils.ts","../src/scopes/components/mini-app/signals.ts","../src/scopes/components/mini-app/methods.ts","../src/scopes/components/popup/prepareParams.ts","../src/scopes/components/popup/popup.ts","../src/scopes/components/qr-scanner/qr-scanner.ts","../src/scopes/components/secondary-button/signals.ts","../src/scopes/components/secondary-button/methods.ts","../src/scopes/components/settings-button/settings-button.ts","../src/scopes/components/swipe-behavior/swipe-behavior.ts","../src/scopes/components/viewport/const.ts","../src/scopes/components/viewport/wrappers.ts","../src/scopes/components/viewport/signals.ts","../src/scopes/components/viewport/static.ts","../src/scopes/components/viewport/mounting.ts","../src/scopes/components/viewport/css-vars.ts","../src/scopes/components/viewport/expand.ts","../src/scopes/components/viewport/fullscreen.ts","../src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts","../src/scopes/utilities/emoji-status/setEmojiStatus.ts","../src/scopes/utilities/home-screen/add-to-home-screen-failed.ts","../src/scopes/utilities/home-screen/added-to-home-screen.ts","../src/scopes/utilities/home-screen/addToHomeScreen.ts","../src/scopes/utilities/home-screen/checkHomeScreenStatus.ts","../src/scopes/utilities/links/openLink.ts","../src/scopes/utilities/links/openTelegramLink.ts","../src/scopes/utilities/links/shareURL.ts","../src/utils/sleep.ts","../src/scopes/utilities/privacy/requestPhoneAccess.ts","../src/scopes/utilities/privacy/requestContact.ts","../src/scopes/utilities/privacy/requestWriteAccess.ts","../src/scopes/utilities/uncategorized/copyTextToClipboard.ts","../src/scopes/utilities/uncategorized/downloadFile.ts","../src/scopes/utilities/uncategorized/getCurrentTime.ts","../src/scopes/utilities/uncategorized/hideKeyboard.ts","../src/scopes/utilities/uncategorized/readTextFromClipboard.ts","../src/scopes/utilities/uncategorized/retrieveAndroidDeviceDataFrom.ts","../src/scopes/utilities/uncategorized/retrieveAndroidDeviceData.ts","../src/scopes/utilities/uncategorized/sendData.ts","../src/scopes/utilities/uncategorized/shareMessage.ts","../src/scopes/utilities/uncategorized/shareStory.ts","../src/scopes/utilities/uncategorized/switchInlineQuery.ts","../src/utils/safeCall.ts","../src/init.ts"],"sourcesContent":["import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}","import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nexport let debug = false;\n\n/**\n * Sets the package debug mode leading to outputting additional logs. This function also modifies\n * debug mode set in the `@telegram-apps/bridge` package.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}","import { createLogger, type Logger } from '@telegram-apps/toolkit';\nimport { signal } from '@telegram-apps/signals';\n\nimport { debug } from '@/debug.js';\n\nexport type { Logger };\nexport const logger = signal<Logger>(createLogger('Bridge', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n}));\n","import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logger } from '@/logger.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_$launchParams, $launchParams] = createSignalsTuple<PackageLaunchParams>({\n  tgWebAppPlatform: 'unknown',\n  tgWebAppVersion: '0.0',\n});\n\nexport const version = createComputed(() => $launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _$launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logger().log('The package was configured. Launch params:', _$launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n","import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}","import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);\n\nexport const [\n  UnknownThemeParamsKeyError,\n  isUnknownThemeParamsKeyError,\n] = errorClass<[key: string]>('UnknownThemeParamsKeyError', key => {\n  return [`Unknown theme params key passed: ${key}`];\n});","/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n","import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n","import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n","import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n","import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}","import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n","import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n","import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n","import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}","import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}","import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n","import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}","import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { AbortablePromise } from 'better-promises';\nimport { array, parse, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      const response = {\n        // Fulfill the response with probably missing keys.\n        ...keys.reduce<Record<string, string>>((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {}),\n        ...parse(record(string(), string()), data),\n      };\n\n      return typeof keyOrKeys === 'string' ? response[keyOrKeys] : response;\n    })\n    : AbortablePromise.resolve(Array.isArray(keyOrKeys) ? {} : '');\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n","import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');","import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}","import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}","import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n","import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n","import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport { batch } from '@telegram-apps/signals';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  (_options?: RequestOptionsNoCapture): AbortablePromise<ThemeParams> => {\n    return AbortablePromise.resolve(\n      (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {},\n    );\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapBasic('mountSync', () => {\n  if (!_isMounted()) {\n    const tp = (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {};\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    batch(() => {\n      _state.set(tp);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}","import type { Computed } from '@telegram-apps/signals';\nimport type { RGB } from '@telegram-apps/types';\nimport { isRGB } from '@telegram-apps/transformers';\n\nimport { state as themeParamsState } from '@/scopes/components/theme-params/signals.js';\nimport { createComputed } from '@/signals-registry.js';\n\nimport type { AnyColor } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nexport function rgbComputedBasedOn(signal: Computed<AnyColor>): Computed<RGB | undefined> {\n  return createComputed<RGB | undefined>(() => rgbBasedOn(signal()));\n}\n\nexport function rgbBasedOn(color: AnyColor): RGB | undefined {\n  return isRGB(color) ? color : themeParamsState()[color];\n}","import { isRGB } from '@telegram-apps/transformers';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  state as themeParamsState,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport { rgbComputedBasedOn } from './utils.js';\n\nimport type { AnyColor, State } from './types.js';\n\n/**\n * The Mini App background color.\n *\n * Represents an RGB color, or theme parameters key, like \"bg_color\", \"secondary_bg_color\", etc.\n *\n * Note that using a theme parameters key, background color becomes bound to the current\n * theme parameters, making it automatically being updated whenever theme parameters change.\n * In order to remove this bind, use an explicit RGB color.\n */\nexport const [_backgroundColor, backgroundColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbComputedBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] = createSignalsTuple<AnyColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    // Falling back to secondary_bg_color following the logic from the Telegram SDK.\n    : themeParamsState()[color] || themeSecondaryBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbComputedBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n","import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { type Computed, type SubscribeListenerFn, batch } from '@telegram-apps/signals';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\n\nimport { version, postEvent } from '@/globals.js';\nimport {\n  mount as mountThemeParams,\n  mountSync as mountThemeParamsSync,\n} from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError, UnknownThemeParamsKeyError } from '@/errors.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { AnyColor, GetCssVarNameFn, State } from './types.js';\nimport { rgbBasedOn } from './utils.js';\nimport { themeParamsState } from '@/scopes/components/theme-params/exports.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst onThemeParamsChanged: SubscribeListenerFn<ThemeParams> = themeParams => {\n  ([\n    [_headerColor, SET_HEADER_COLOR_METHOD],\n    [_backgroundColor, SET_BG_COLOR_METHOD],\n    [_bottomBarColor, SET_BOTTOM_BAR_COLOR_METHOD],\n  ] as const).forEach(([signal, method]) => {\n    const color = signal();\n    if (!isRGB(color) && (\n      // Header color setter uses additional checks. We don't apply changes if the current\n      // value is a known color key because it updates automatically by itself.\n      method !== SET_HEADER_COLOR_METHOD\n      || (color !== 'bg_color' && color !== 'secondary_bg_color')\n    )) {\n      const rgb = themeParams[color];\n      rgb && postEvent(method, { color: rgb });\n    }\n  });\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapSupported('mountSync', () => {\n  if (!_isMounted()) {\n    mountThemeParamsSync();\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n\n    batch(() => {\n      _isActive.set(s ? s.isActive : true);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: AnyColor): void => {\n    if (color === _backgroundColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BG_COLOR_METHOD, { color: rgb });\n    _backgroundColor.set(color);\n    saveState();\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('#ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: AnyColor) => {\n    if (color === _bottomBarColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color: rgb });\n    _bottomBarColor.set(color);\n    saveState();\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: AnyColor): void => {\n    if (color === _headerColor()) {\n      return;\n    }\n    if (color === 'bg_color' || color === 'secondary_bg_color') {\n      postEvent(SET_HEADER_COLOR_METHOD, { color_key: color });\n    } else {\n      const rgb = rgbBasedOn(color);\n      if (!rgb) {\n        throw new UnknownThemeParamsKeyError(color);\n      }\n      postEvent(SET_HEADER_COLOR_METHOD, { color: rgb });\n    }\n    _headerColor.set(color);\n    saveState();\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  themeParamsState.unsub(onThemeParamsChanged);\n  _isMounted.set(false);\n}\n","import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}","import type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { ShowOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [fn, tPromise, tShowError] = defineNonConcurrentFn(\n  (options: ShowOptions): AbortablePromise<string | null> => {\n    return request(OPEN_METHOD, 'popup_closed', {\n      ...options,\n      params: prepareParams(options),\n    }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n  },\n  'A popup is already opened',\n);\n\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `show` instead.\n */\nexport const open = wrapSupported('open', fn);\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showPromise` instead.\n */\nconst openPromise = tPromise[1];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `isShown` instead.\n */\nconst isOpened = tPromise[2];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showError` instead.\n */\nconst openError = tShowError[1];\n\nexport { openPromise, isOpened, openError };\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const show = wrapSupported('show', fn);\nexport const [, showPromise, isShown] = tPromise;\nexport const [, showError] = tShowError;\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;","import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n","import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}","import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n","export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n","import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion","import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);","import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = $launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n","import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n","import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n","import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;","import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;","import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);","import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;","import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);","import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);","import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n","import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;","import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n    [key: string]: unknown;\n  };\n  auth_date: Date;\n  hash: string;\n  [key: string]: unknown;\n}\n\n/**\n * Requested contact complete data.\n */\nexport interface RequestedContactCompleteData {\n  /**\n   * Raw original representation of the contact data returned from the Telegram server.\n   */\n  raw: string;\n  /**\n   * Parsed representation of the contact data.\n   */\n  parsed: RequestedContact;\n}\n\nconst fnOptions = {\n  isSupported: 'web_app_request_phone',\n} as const;\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContactCompleteData> {\n  const raw = parse(string(), await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  }));\n  return {\n    raw,\n    parsed: parse(\n      pipe(\n        // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n        union([string(), instance(URLSearchParams)]),\n        transformQueryUsing(\n          looseObject({\n            contact: pipe(\n              string(),\n              jsonParse(),\n              looseObject({\n                user_id: number(),\n                phone_number: string(),\n                first_name: string(),\n                last_name: optional(string()),\n              }),\n            ),\n            auth_date: pipe(\n              string(),\n              transform(input => new Date(Number(input) * 1000)),\n              date(),\n            ),\n            hash: string(),\n          }),\n        ),\n      ),\n      raw,\n    ),\n  };\n}\n\nconst [fn, tPromise, tError] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContactCompleteData> => {\n    return new AbortablePromise<RequestedContactCompleteData>(\n      async (res, _, context) => {\n        // First of all, let's try to get the requested contact. Probably, we already requested it\n        // before.\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Then, request access to the user's phone.\n        const status = await requestPhoneAccess(context);\n        if (status !== 'sent') {\n          throw new AccessDeniedError('User denied access');\n        }\n\n        // Time to wait before executing the next request.\n        let sleepTime = 50;\n\n        // We are trying to retrieve the requested contact until the deadline was reached.\n        while (!context.isAborted()) {\n          try {\n            return res(await getRequestedContact(context));\n          } catch (e) {\n            if (e instanceof ValiError) {\n              throw e;\n            }\n          }\n\n          // Sleep for some time.\n          await sleep(sleepTime);\n\n          // Increase the sleep time not to kill the backend service.\n          sleepTime += 50;\n        }\n      },\n      options,\n    );\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n *\n * This function returns an object, containing both raw and parsed representations of the response,\n * received from the Telegram client.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContactComplete.isAvailable()) {\n *   const completeData = await requestContactComplete();\n * }\n */\nexport const requestContactComplete = wrapSafe('requestContactComplete', fn, fnOptions);\n\n/**\n * Works the same way as the `requestContactComplete` function, but returns only parsed\n * representation of the contact data.\n * @see requestContactComplete\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe(\n  'requestContact',\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return requestContactComplete(options).then(r => r.parsed);\n  },\n  fnOptions,\n);\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;","import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n","function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}","import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);","import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);","import { postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst HIDE_KEYBOARD_METHOD = 'web_app_hide_keyboard';\n\n/**\n * Hides the on-screen keyboard, if it is currently visible. Does nothing if the keyboard is \n * not active.\n * @since Mini Apps v9.1\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using `.isAvailable()`\n * if (hideKeyboard.isAvailable()) {\n *   hideKeyboard();\n * }\n * @example Using `.ifAvailable()`\n * hideKeyboard.ifAvailable()\n */\nexport const hideKeyboard = wrapSafe(\n  'hideKeyboard',\n  () => postEvent(HIDE_KEYBOARD_METHOD),\n  { isSupported: HIDE_KEYBOARD_METHOD },\n);\n","import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);","export interface AndroidDeviceData {\n  appVersion?: string;\n  manufacturer?: string;\n  model?: string;\n  androidVersion?: string;\n  sdkVersion?: number;\n  performanceClass?: 'LOW' | 'AVERAGE' | 'HIGH' | string;\n}\n\n/**\n * Retrieves Android device data from the specified User Agent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n * @param userAgent - user agent.\n */\nexport function retrieveAndroidDeviceDataFrom(userAgent: string): AndroidDeviceData {\n  const result: AndroidDeviceData = {};\n  const match = userAgent.match(/Telegram-Android(?:\\/([^ ]+))?(?: (\\([^)]+\\))?|$)/);\n  if (match) {\n    const [, appVersion, systemInfo] = match;\n    appVersion && (result.appVersion = appVersion);\n    systemInfo && systemInfo\n      .slice(1, systemInfo.length - 1)\n      .split(';')\n      .forEach(item => {\n        const [key, value] = item.trim().split(' ');\n        if (key === 'Android') {\n          result.androidVersion = value;\n        } else if (key === 'SDK') {\n          const parsed = parseInt(value, 10);\n          parsed && (result.sdkVersion = parsed);\n        } else if (value) {\n          result.manufacturer = key;\n          result.model = value;\n        } else {\n          result.performanceClass = key;\n        }\n      });\n  }\n  return result;\n}","import {\n  type AndroidDeviceData,\n  retrieveAndroidDeviceDataFrom,\n} from './retrieveAndroidDeviceDataFrom.js';\n\n/**\n * Retrieves Android device data from the navigator.userAgent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n */\nexport function retrieveAndroidDeviceData(): AndroidDeviceData {\n  return retrieveAndroidDeviceDataFrom(navigator.userAgent);\n}","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_data_send';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent(METHOD_NAME, { data });\n  },\n  { isSupported: METHOD_NAME },\n);\n","import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);","import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);","import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { $launchParams, postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n  {\n    isSupported() {\n      return $launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    }\n  }\n);\n","export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n","import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logger } from '@/logger.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logger().log('Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logger().log('The package was initialized');\n\n  return cleanup;\n}"],"names":["createSignal","initialValue","options","signal","createComputed","fn","computed","createSignalsTuple","s","debug","setDebug","value","setBridgeDebug","logger","createLogger","$lastRequestId","$postEvent","_postEvent","_$launchParams","$launchParams","version","configure","postEvent","lp","retrieveLaunchParams","createPostEvent","createRequestId","invokeCustomMethod","method","params","_invokeCustomMethod","request","eventOrEvents","_request","createIsSupported","supports","proxyMessage","message","CSSVarsBoundError","isCSSVarsBoundError","errorClass","NotAvailableError","isNotAvailableError","InvalidEnvError","isInvalidEnvError","FunctionUnavailableError","isFunctionNotAvailableError","InvalidArgumentsError","isInvalidArguments","cause","ConcurrentCallError","isConcurrentCallError","SetEmojiStatusError","isSetEmojiStatusError","error","AccessDeniedError","isAccessDeniedError","FullscreenFailedError","isFullscreenFailedError","ShareMessageError","isShareMessageError","UnknownThemeParamsKeyError","isUnknownThemeParamsKeyError","key","isSSR","wrapSafe","optionsIsSupported","isMounted","isMounting","component","optionSupports","functionId","isSupported","supportsOption","option","tuple","supportError","getError","item","isSupportedItems","errors","supportsOptionError","args","k","supportsMap","$isSupported","$isInitialized","$isMounted","$isAvailable","isTMA","errMessagePrefix","supportErr","supportsOptionErr","createWrapSafe","overrideIsSupported","createWrapComplete","createWrapSupported","SETUP_METHOD_NAME","CLICK_EVENT_NAME","COMPONENT_NAME","_isVisible","isVisible","_isMounted","wrapComplete","wrapSupported","hide","setVisibility","mount","isPageReload","getStorageValue","setStorageValue","onClick","on","offClick","off","show","unmount","defineNonConcurrentFn","errorMessage","optionsPromise","optionsError","_promise","promise","_error","err","AbortablePromise","batch","e","defineMountFn","onMounted","rest","data","_state","state","isAvailable","METHOD_NAME","requestBiometry","ignoreCanceled","isCancelledError","signalCancel","p","REQUEST_AUTH_METHOD","INFO_RECEIVED_EVENT","onBiometryInfoReceived","setState","eventToState","throwNotAvailable","event","available","tokenSaved","deviceId","accessRequested","type","accessGranted","mountFn","tMountPromise","tMountError","tIsMounted","abortSignal","mountPromise","mountError","authFn","tAuthPromise","tAuthError","context","token","authenticate","authPromise","isAuthenticating","authError","openSettings","requestAccessFn","tRequestAccessPromise","tRequestAccessError","requestAccess","requestAccessPromise","isRequestingAccess","requestAccessError","updateToken","r","createWrapMounted","createWrapBasic","_isConfirmationEnabled","isConfirmationEnabled","wrapMounted","wrapBasic","disableConfirmation","setClosingConfirmation","enableConfirmation","INVOKE_METHOD_NAME","deleteItem","keyOrKeys","keys","_getItem","response","acc","parse","record","string","getItem","getKeys","array","setItem","clear","HAPTIC_METHOD_NAME","impactOccurred","style","notificationOccurred","selectionChanged","fromState","authDate","canSendAfter","canSendAfterDate","authDateValue","canSendAfterValue","chat","chatType","chatInstance","hash","queryId","_raw","raw","receiver","restore","retrieveRawInitData","startParam","user","_open","urlOrSlug","optionsOrType","slug","hostname","pathname","match","d","tOpenPromise","tOpenError","open","openPromise","isOpened","openError","CHECK_LOCATION_METHOD","OPEN_SETTINGS_METHOD","isAccessGranted","isAccessRequested","reqLocationFn","tReqLocationPromise","tReqLocationError","requestLocation","requestLocationPromise","isRequestingLocation","requestLocationError","removeUndefined","result","v","isColorDark","color","rgb","toRGB","modifier","idx","dec","_isCssVarsBound","isCssVarsBound","accentTextColor","backgroundColor","buttonColor","buttonTextColor","bottomBarBgColor","destructiveTextColor","headerBackgroundColor","hintColor","isDark","linkColor","secondaryBackgroundColor","sectionBackgroundColor","sectionHeaderTextColor","sectionSeparatorColor","subtitleTextColor","textColor","internalState","hasShineEffect","isEnabled","isLoaderVisible","text","prev","setParams","updates","setCssVar","name","deleteCssVar","THEME_CHANGED_EVENT","onThemeChanged","_options","bindCssVars","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","mountSync","tp","rgbComputedBasedOn","rgbBasedOn","isRGB","themeParamsState","_backgroundColor","backgroundColorRGB","_bottomBarColor","bottomBarColor","bottomBarColorRGB","themeSecondaryBgColor","_headerColor","headerColor","headerColorRGB","_isActive","isActive","SET_BG_COLOR_METHOD","SET_BOTTOM_BAR_COLOR_METHOD","SET_HEADER_COLOR_METHOD","VISIBILITY_CHANGED_EVENT","isSupportedSchema","onVisibilityChanged","saveState","onThemeParamsChanged","themeParams","mountThemeParams","setBackgroundColor","setBottomBarColor","setHeaderColor","addCleanup","cleanup","createCbCollector","bind","cssVar","update","camelToKebab","close","returnBack","mountThemeParamsSync","ready","prepareParams","title","buttons","b","id","OPEN_METHOD","tPromise","tShowError","buttonId","showPromise","isShown","showError","CLOSE_METHOD","CLOSED_EVENT","TEXT_RECEIVED_EVENT","onCaptured","capture","ManualPromise","openFn","position","_isVerticalEnabled","isVerticalEnabled","disableVertical","setVerticalEnabled","enableVertical","force","FS_CHANGED_EVENT","SA_CHANGED_EVENT","CSA_CHANGED_EVENT","VIEWPORT_CHANGED_EVENT","initialInsets","nonNegative","signalFromState","height","stableHeight","width","isExpanded","isStable","getStateFromStorage","fromCsaState","contentSafeAreaInsets","contentSafeAreaInsetBottom","contentSafeAreaInsetLeft","contentSafeAreaInsetRight","contentSafeAreaInsetTop","fromSaState","safeAreaInsets","safeAreaInsetBottom","safeAreaInsetLeft","safeAreaInsetRight","safeAreaInsetTop","REQUEST_SA_METHOD_NAME","requestContentSafeAreaInsets","requestViewport","requestSafeAreaInsets","onViewportChanged","onFullscreenChanged","onSafeAreaChanged","onContentSafeAreaChanged","insets","shared","w","settings","setting","expand","REQUEST_METHOD_NAME","isFullscreen","_changeFullscreenPromise","changeFullscreenPromise","_changeFullscreenError","changeFullscreenError","createFullscreenFn","isRequest","requestFullscreen","exitFullscreen","METHOD","tError","requestEmojiStatusAccess","requestEmojiStatusAccessPromise","isRequestingEmojiStatusAccess","requestEmojiStatusAccessError","customEmojiId","setEmojiStatus","setEmojiStatusPromise","isSettingEmojiStatus","setEmojiStatusError","wrapOptions","EVENT_NAME","onAddToHomeScreenFailed","listener","once","offAddToHomeScreenFailed","onAddedToHomeScreen","offAddedToHomeScreen","addToHomeScreen","checkHomeScreenStatus","checkHomeScreenStatusPromise","isCheckingHomeScreenStatus","checkHomeScreenStatusError","openLink","url","OPEN_TG_LINK_METHOD","openTelegramLink","urlString","shareURL","sleep","duration","requestPhoneAccess","requestPhoneAccessPromise","isRequestingPhoneAccess","requestPhoneAccessError","fnOptions","getRequestedContact","pipe","union","instance","transformQueryUsing","looseObject","jsonParse","number","optional","transform","input","date","res","_","ValiError","sleepTime","requestContactComplete","requestContact","requestContactPromise","isRequestingContact","requestContactError","requestWriteAccess","requestWriteAccessPromise","isRequestingWriteAccess","requestWriteAccessError","fallback","textArea","copyTextToClipboard","clipboard","downloadFile","fileName","getCurrentTime","integer","HIDE_KEYBOARD_METHOD","hideKeyboard","readTextFromClipboard","reqId","captureSameReq","retrieveAndroidDeviceDataFrom","userAgent","appVersion","systemInfo","parsed","retrieveAndroidDeviceData","sendData","size","shareMessage","SHARE_STORY_METHOD","shareStory","mediaUrl","SWITCH_INLINE_QUERY_METHOD","switchInlineQuery","query","chatTypes","safeCall","init","acceptCustomStyles","html"],"mappings":"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"}