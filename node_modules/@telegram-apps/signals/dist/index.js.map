{"version":3,"file":"index.js","sources":["../src/batch.ts","../src/signal.ts","../src/computed.ts"],"sourcesContent":["import { Signal } from './signal.js';\n\nlet callbacks: Map<Signal<any>, () => void> | undefined;\n\nexport function runInBatchMode(signal: Signal<any>, fn: () => void): void {\n  callbacks && callbacks.set(signal, fn) || fn();\n}\n\n/**\n * Runs the specified function in the batch mode.\n *\n * It makes all signals' subscribers to be called only after signals changes inside the specified\n * function were applied.\n * @param fn - function to run in the batch mode.\n * @example\n * const a = signal(1);\n * const b = signal(1);\n * const c = computed(() => a() + b());\n *\n * function subscriber(value) {\n *   console.log(value);\n * }\n *\n * c.sub(subscriber);\n *\n * batch(() => {\n *   a.set(2);\n *   a.set(3);\n *   b.set(2);\n *   b.set(3);\n * });\n *\n * // Despite the fact that we called signals setters four times, the `subscriber` function will\n * // be called only once. Removing the `batch` function usage will lead to calling the `subscriber`\n * // function four times.\n */\nexport function batch(fn: () => void): void {\n  // There could be a case when a batch is called inside other batches.\n  // In this case, we should just ignore the current call.\n  if (callbacks) {\n    return fn();\n  }\n  callbacks = new Map();\n\n  try {\n    fn();\n  } finally {\n    callbacks.forEach(cb => cb());\n    callbacks = undefined;\n    // TODO: What if something went wrong in fn or its callbacks?\n  }\n}\n","import { collectSignal } from './computed.js';\nimport { runInBatchMode } from './batch.js';\n\nexport type SubscribeListenerFn<T> = (current: T, previous: T) => void;\nexport type RemoveListenerFn = () => void;\n\nexport interface SignalOptions<T> {\n  /**\n   * Previous and next values comparator.\n   *\n   * This function is used during the actual and incoming values comparison in the `set` method.\n   * If values are considered the same, no subscribers will be called.\n   *\n   * @default Object.is\n   * @param current - the actual value.\n   * @param next - an incoming value.\n   * @returns True if values are considered the same.\n   */\n  equals?: (current: T, next: T) => boolean;\n}\n\nexport interface SubOptions {\n  /**\n   * Should the listener be called only once.\n   */\n  once?: boolean;\n  /**\n   * True if the subscriber was added by another signal.\n   */\n  signal?: boolean;\n}\n\nexport interface Signal<T> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n  /**\n   * Destroys the signal removing all bound listeners.\n   *\n   * We usually use this method when the signal is not needed anymore.\n   *\n   * Take note that as long as call of this method removes all bound listeners, computed signals\n   * based on the current one will stop listening to its changes, possibly making it work\n   * improperly.\n   */\n  destroy: () => void;\n  /**\n   * Resets the signal to its initial value.\n   */\n  reset: () => void;\n  /**\n   * Updates the signal notifying all subscribers about changes.\n   * @param value - value to set.\n   */\n  set: (value: T) => void;\n  /**\n   * Adds a new listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options.\n   * @returns A function to remove the bound listener.\n   */\n  sub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => RemoveListenerFn;\n  /**\n   * Removes a listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options. Default: false\n   */\n  unsub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => void;\n  /**\n   * Remove all non-signal listeners.\n   */\n  unsubAll: () => void;\n}\n\n/**\n * Creates a new signal with initial value.\n * @param initialValue - initial value.\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without initial value.\n * @param initialValue\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  type CurrentSignal = Signal<T | undefined>;\n\n  options ||= {};\n  const equals = options.equals || Object.is;\n\n  let listeners: [\n    listener: SubscribeListenerFn<T | undefined>,\n    options: Required<SubOptions>\n  ][] = [];\n  let value: ReturnType<CurrentSignal> = initialValue;\n\n  const set: CurrentSignal['set'] = v => {\n    if (!equals(value, v)) {\n      const prev = value;\n      value = v;\n\n      // We are making a copy of listeners as long as they may mutate the listeners' array,\n      // leading to an unexpected behavior.\n      //\n      // We want the setter to make sure that all listeners will be called in predefined\n      // order within a single update frame.\n      runInBatchMode(s, () => {\n        [...listeners].forEach(([fn, once]) => {\n          fn(v, prev);\n\n          // Remove \"once\" listeners.\n          if (once) {\n            unsub(fn, true);\n          }\n        });\n      });\n    }\n  };\n\n  function formatSubOptions(onceOrOptions: boolean | SubOptions | undefined): Required<SubOptions> {\n    const options = typeof onceOrOptions !== 'object'\n      ? { once: onceOrOptions }\n      : onceOrOptions;\n    return {\n      once: options.once || false,\n      signal: options.signal || false,\n    };\n  }\n\n  const unsub: CurrentSignal['unsub'] = (fn, onceOrOptions) => {\n    const options = formatSubOptions(onceOrOptions);\n    const idx = listeners.findIndex(([listener, lOptions]) => {\n      return listener === fn\n        && lOptions.once === options.once\n        && lOptions.signal === options.signal;\n    });\n    if (idx >= 0) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  const s = Object.assign(\n    function get() {\n      collectSignal(s);\n      return value;\n    },\n    {\n      destroy() {\n        listeners = [];\n      },\n      set,\n      reset() {\n        set(initialValue);\n      },\n      sub(fn, onceOrOptions) {\n        listeners.push([fn, formatSubOptions(onceOrOptions)]);\n        return () => unsub(fn, onceOrOptions);\n      },\n      unsub,\n      unsubAll() {\n        listeners = listeners.filter(l => l[1].signal);\n      },\n    } satisfies Pick<CurrentSignal, 'destroy' | 'set' | 'reset' | 'sub' | 'unsub' | 'unsubAll'>,\n  );\n\n  return s;\n}\n","import { signal, type Signal, type SignalOptions } from './signal.js';\n\nexport interface Computed<T> extends Omit<Signal<T>, 'set' | 'reset'> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n}\n\nconst collectContexts: Set<Signal<unknown>>[] = [];\n\nexport function collectSignal(signal: Signal<any>): void {\n  collectContexts.length && collectContexts[collectContexts.length - 1].add(signal);\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function computed<T>(\n  fn: (prev?: T) => T,\n  options?: SignalOptions<T>,\n): Computed<T> {\n  let deps = new Set<Signal<unknown>>();\n\n  // An underlying signal.\n  let $signal: Signal<T> | undefined;\n\n  function s(): Signal<T> {\n    return $signal || ($signal = signal<T>(compute(), options));\n  }\n\n  function update() {\n    s().set(compute());\n  }\n\n  function compute(): T {\n    // As long as in this iteration, we may receive new signals as dependencies, we stop\n    // listening to the previous signals.\n    deps.forEach(s => {\n      s.unsub(update, { signal: true });\n    });\n\n    // Signals we collected during current computation.\n    const collectedSignals = new Set<Signal<unknown>>();\n    let result: T;\n\n    // Add this set to the global variable, so dependant signals will be catched.\n    collectContexts.push(collectedSignals);\n\n    try {\n      // Run the function and collect all called signals.\n      result = fn();\n    } finally {\n      // Remember to untrack the reactive context.\n      collectContexts.pop();\n    }\n\n    // Start tracking for all dependencies' changes and re-compute the computed value.\n    collectedSignals.forEach(s => {\n      s.sub(update, { signal: true });\n    });\n    deps = collectedSignals;\n\n    return result;\n  }\n\n  return Object.assign(function computed(): T {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...args) {\n      return s().sub(...args);\n    },\n    unsub(...args) {\n      s().unsub(...args);\n    },\n    unsubAll(...args) {\n      s().unsubAll(...args);\n    },\n  } satisfies Pick<Computed<T>, 'destroy' | 'sub' | 'unsub' | 'unsubAll'>);\n}\n"],"names":["callbacks","runInBatchMode","signal","fn","batch","cb","initialValue","options","equals","listeners","value","set","v","prev","s","once","unsub","formatSubOptions","onceOrOptions","idx","listener","lOptions","collectSignal","l","collectContexts","computed","deps","$signal","compute","update","collectedSignals","result","args"],"mappings":"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"}